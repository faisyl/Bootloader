   1               	 .file "main.c"
   2               	__SP_H__ =0x3e
   3               	__SP_L__ =0x3d
   4               	__SREG__ =0x3f
   5               	__tmp_reg__ =0
   6               	__zero_reg__ =1
   9               	 .text
  10               	.Ltext0:
 121               	 .section .text.__vector_40,"ax",@progbits
 123               	.global __vector_40
 125               	__vector_40:
 126               	 .stabd 46,0,0
   1:main.c        **** /***************************************************************************
   2:main.c        ****  *   Copyright (C) 08/2010 by Olaf Rempel                                  *
   3:main.c        ****  *   razzor@kopf-tisch.de                                                  *
   4:main.c        ****  *                                                                         *
   5:main.c        ****  *   This program is free software; you can redistribute it and/or modify  *
   6:main.c        ****  *   it under the terms of the GNU General Public License as published by  *
   7:main.c        ****  *   the Free Software Foundation; version 2 of the License,               *
   8:main.c        ****  *                                                                         *
   9:main.c        ****  *   This program is distributed in the hope that it will be useful,       *
  10:main.c        ****  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  11:main.c        ****  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  12:main.c        ****  *   GNU General Public License for more details.                          *
  13:main.c        ****  *                                                                         *
  14:main.c        ****  *   You should have received a copy of the GNU General Public License     *
  15:main.c        ****  *   along with this program; if not, write to the                         *
  16:main.c        ****  *   Free Software Foundation, Inc.,                                       *
  17:main.c        ****  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  18:main.c        ****  ***************************************************************************/
  19:main.c        **** #include <avr/io.h>
  20:main.c        **** #include <avr/interrupt.h>
  21:main.c        **** #include <avr/boot.h>
  22:main.c        **** #include <avr/pgmspace.h>
  23:main.c        **** #include "port_init.h"
  24:main.c        **** 
  25:main.c        **** /*
  26:main.c        ****  * atmega328pb:
  27:main.c        ****  * Fuse E: 0xfd (2.7V BOD)
  28:main.c        ****  * Fuse H: 0xd4 (512 words bootloader)
  29:main.c        ****  * Fuse L: 0xc2 (8Mhz internal RC-Osz.)
  30:main.c        ****  */
  31:main.c        **** 
  32:main.c        **** #if defined (__AVR_ATmega328PB__)
  33:main.c        **** //#define VERSION_STRING		"TWIBOOTm328v2.1"
  34:main.c        **** #define VERSION_STRING		"KLBOOT328PBv2.1"
  35:main.c        **** #define SIGNATURE_BYTES		0x1E, 0x95, 0x16
  36:main.c        **** 
  37:main.c        **** #else
  38:main.c        **** #error MCU not supported
  39:main.c        **** #endif
  40:main.c        **** 
  41:main.c        **** #define EEPROM_SUPPORT		1
  42:main.c        **** #define LED_SUPPORT		    1
  43:main.c        **** 
  44:main.c        **** /* 25ms @8MHz */
  45:main.c        **** #define TIMER_RELOAD		(0xFF - 195)
  46:main.c        **** 
  47:main.c        **** /* 40 * 25ms = 1 sec */
  48:main.c        **** #define TIMEOUT			40
  49:main.c        **** /* 200 * 25ms = 5 sec */
  50:main.c        **** //#define TIMEOUT			200
  51:main.c        **** 
  52:main.c        **** #if LED_SUPPORT
  53:main.c        **** #define LED_INIT()		  LED_set_dir(PORT_DIR_OUT);
  54:main.c        **** #define LED_RT_ON()		  LED_set_level(false);
  55:main.c        **** #define LED_RT_OFF()      LED_set_level(true);
  56:main.c        **** #define LED_GN_OFF()	  LED_set_level(true);
  57:main.c        **** #define LED_GN_ON()		  LED_set_level(false);
  58:main.c        **** #define LED_GN_TOGGLE()	  LED_toggle_level();
  59:main.c        **** #define LED_OFF()		  LED_set_level(true);
  60:main.c        **** #else
  61:main.c        **** #define LED_INIT()
  62:main.c        **** #define LED_RT_ON()
  63:main.c        **** #define LED_RT_OFF()
  64:main.c        **** #define LED_GN_ON()
  65:main.c        **** #define LED_GN_OFF()
  66:main.c        **** #define LED_GN_TOGGLE()
  67:main.c        **** #define LED_OFF()
  68:main.c        **** #endif
  69:main.c        **** 
  70:main.c        **** #ifndef TWI_ADDRESS
  71:main.c        **** // This is so the firmware can be updated "in-service"
  72:main.c        **** // It drops to an unused address.
  73:main.c        **** #define TWI_ADDRESS		0x08 // I2C "Reserved for future purposes"
  74:main.c        **** #endif
  75:main.c        **** 
  76:main.c        **** /* SLA+R */
  77:main.c        **** #define CMD_WAIT		0x00
  78:main.c        **** #define CMD_READ_VERSION	0x01
  79:main.c        **** #define CMD_READ_MEMORY		0x02
  80:main.c        **** /* internal mappings */
  81:main.c        **** #define CMD_READ_CHIPINFO	(0x10 | CMD_READ_MEMORY)
  82:main.c        **** #define CMD_READ_FLASH		(0x20 | CMD_READ_MEMORY)
  83:main.c        **** #define CMD_READ_EEPROM		(0x30 | CMD_READ_MEMORY)
  84:main.c        **** #define CMD_READ_PARAMETERS	(0x40 | CMD_READ_MEMORY)	/* only in APP */
  85:main.c        **** 
  86:main.c        **** /* SLA+W */
  87:main.c        **** #define CMD_SWITCH_APPLICATION	CMD_READ_VERSION
  88:main.c        **** #define CMD_WRITE_MEMORY	CMD_READ_MEMORY
  89:main.c        **** /* internal mappings */
  90:main.c        **** #define CMD_BOOT_BOOTLOADER	(0x10 | CMD_SWITCH_APPLICATION)	/* only in APP */
  91:main.c        **** #define CMD_BOOT_APPLICATION	(0x20 | CMD_SWITCH_APPLICATION)
  92:main.c        **** #define CMD_WRITE_CHIPINFO	(0x10 | CMD_WRITE_MEMORY)	/* invalid */
  93:main.c        **** #define CMD_WRITE_FLASH		(0x20 | CMD_WRITE_MEMORY)
  94:main.c        **** #define CMD_WRITE_EEPROM	(0x30 | CMD_WRITE_MEMORY)
  95:main.c        **** #define CMD_WRITE_PARAMETERS	(0x40 | CMD_WRITE_MEMORY)	/* only in APP */
  96:main.c        **** 
  97:main.c        **** /* CMD_SWITCH_APPLICATION parameter */
  98:main.c        **** #define BOOTTYPE_BOOTLOADER	0x00				/* only in APP */
  99:main.c        **** #define BOOTTYPE_APPLICATION	0x80
 100:main.c        **** 
 101:main.c        **** /* CMD_{READ|WRITE}_* parameter */
 102:main.c        **** #define MEMTYPE_CHIPINFO	0x00
 103:main.c        **** #define MEMTYPE_FLASH		0x01
 104:main.c        **** #define MEMTYPE_EEPROM		0x02
 105:main.c        **** #define MEMTYPE_PARAMETERS	0x03				/* only in APP */
 106:main.c        **** 
 107:main.c        **** /*
 108:main.c        ****  * LED_GN blinks with 20Hz (while bootloader is running)
 109:main.c        ****  * LED_RT blinks on TWI activity
 110:main.c        ****  *
 111:main.c        ****  * bootloader twi-protocol:
 112:main.c        ****  * - abort boot timeout:
 113:main.c        ****  *   SLA+W, 0x00, STO
 114:main.c        ****  *
 115:main.c        ****  * - show bootloader version
 116:main.c        ****  *   SLA+W, 0x01, SLA+R, {16 bytes}, STO
 117:main.c        ****  *
 118:main.c        ****  * - start application
 119:main.c        ****  *   SLA+W, 0x01, 0x80, STO
 120:main.c        ****  *
 121:main.c        ****  * - read chip info: 3byte signature, 1byte page size, 2byte flash size, 2byte eeprom size
 122:main.c        ****  *   SLA+W, 0x02, 0x00, 0x00, 0x00, SLA+R, {4 bytes}, STO
 123:main.c        ****  *
 124:main.c        ****  * - read one (or more) flash bytes
 125:main.c        ****  *   SLA+W, 0x02, 0x01, addrh, addrl, SLA+R, {* bytes}, STO
 126:main.c        ****  *
 127:main.c        ****  * - read one (or more) eeprom bytes
 128:main.c        ****  *   SLA+W, 0x02, 0x02, addrh, addrl, SLA+R, {* bytes}, STO
 129:main.c        ****  *
 130:main.c        ****  * - write one flash page (64bytes on mega8)
 131:main.c        ****  *   SLA+W, 0x02, 0x01, addrh, addrl, {64 bytes}, STO
 132:main.c        ****  *
 133:main.c        ****  * - write one (or more) eeprom bytes
 134:main.c        ****  *   SLA+W, 0x02, 0x02, addrh, addrl, {* bytes}, STO
 135:main.c        ****  */
 136:main.c        **** 
 137:main.c        **** const static uint8_t info[16] = VERSION_STRING;
 138:main.c        **** const static uint8_t chipinfo[8] = {
 139:main.c        **** 	SIGNATURE_BYTES,
 140:main.c        **** 
 141:main.c        **** 	SPM_PAGESIZE,
 142:main.c        **** 
 143:main.c        **** 	(BOOTLOADER_START >> 8) & 0xFF,
 144:main.c        **** 	BOOTLOADER_START & 0xFF,
 145:main.c        **** #if (EEPROM_SUPPORT)
 146:main.c        **** 	((E2END +1) >> 8 & 0xFF),
 147:main.c        **** 	(E2END +1) & 0xFF
 148:main.c        **** #else
 149:main.c        **** 	0x00, 0x00
 150:main.c        **** #endif
 151:main.c        **** };
 152:main.c        **** 
 153:main.c        **** /* wait 40 * 25ms = 1s */
 154:main.c        **** static uint8_t boot_timeout = TIMEOUT;
 155:main.c        **** volatile static uint8_t cmd = CMD_WAIT;
 156:main.c        **** 
 157:main.c        **** /* flash buffer */
 158:main.c        **** static uint8_t buf[SPM_PAGESIZE];
 159:main.c        **** static uint16_t addr;
 160:main.c        **** 
 161:main.c        **** static void write_flash_page(void)
 162:main.c        **** {
 163:main.c        **** 	uint16_t pagestart = addr;
 164:main.c        **** 	uint8_t size = SPM_PAGESIZE;
 165:main.c        **** 	uint8_t *p = buf;
 166:main.c        **** 
 167:main.c        **** 	//Don't overwrite bootloader
 168:main.c        **** 	if (pagestart >= BOOTLOADER_START)
 169:main.c        **** 		return;
 170:main.c        **** 
 171:main.c        **** 	boot_page_erase(pagestart);
 172:main.c        **** 	boot_spm_busy_wait();
 173:main.c        **** 
 174:main.c        **** 	do {
 175:main.c        **** 		uint16_t data = *p++;
 176:main.c        **** 		data |= *p++ << 8;
 177:main.c        **** 		boot_page_fill(addr, data);
 178:main.c        **** 
 179:main.c        **** 		addr += 2;
 180:main.c        **** 		size -= 2;
 181:main.c        **** 	} while (size);
 182:main.c        **** 
 183:main.c        **** 	boot_page_write(pagestart);
 184:main.c        **** 	boot_spm_busy_wait();
 185:main.c        **** 	boot_rww_enable();
 186:main.c        **** }
 187:main.c        **** 
 188:main.c        **** #if (EEPROM_SUPPORT)
 189:main.c        **** static uint8_t read_eeprom_byte(void)
 190:main.c        **** {
 191:main.c        **** 	EEARL = addr;
 192:main.c        **** 	EEARH = (addr >> 8);
 193:main.c        **** 	EECR |= (1<<EERE);
 194:main.c        **** 	addr++;
 195:main.c        **** 	return EEDR;
 196:main.c        **** }
 197:main.c        **** 
 198:main.c        **** static void write_eeprom_byte(uint8_t val)
 199:main.c        **** {
 200:main.c        **** 	EEARL = addr;
 201:main.c        **** 	EEARH = (addr >> 8);
 202:main.c        **** 	EEDR = val;
 203:main.c        **** 	addr++;
 204:main.c        **** 
 205:main.c        **** 	EECR |= (1<<EEMPE);
 206:main.c        **** 	EECR |= (1<<EEPE);
 207:main.c        **** 
 208:main.c        **** 	eeprom_busy_wait();
 209:main.c        **** }
 210:main.c        **** #endif /* EEPROM_SUPPORT */
 211:main.c        **** 
 212:main.c        **** ISR(TWI1_vect)
 213:main.c        **** {
 128               	.LM0:
 129               	.LFBB1:
 130 0000 0F92 0FB6 	 __gcc_isr 1
 130      0F92 1F92 
 130      1124 2F93 
 131 000c 3F93      	 push r19
 132 000e 4F93      	 push r20
 133 0010 5F93      	 push r21
 134 0012 6F93      	 push r22
 135 0014 8F93      	 push r24
 136 0016 9F93      	 push r25
 137 0018 AF93      	 push r26
 138 001a BF93      	 push r27
 139 001c EF93      	 push r30
 140 001e FF93      	 push r31
 141               	 
 142               	 
 143               	 
 144               	.L__stack_usage =10+__gcc_isr.n_pushed
 214:main.c        **** 	static uint8_t bcnt;
 215:main.c        **** 	uint8_t data;
 216:main.c        **** 	uint8_t ack = (1<<TWEA);
 217:main.c        **** 
 218:main.c        **** 	switch (TWSR1 & 0xF8) {
 146               	.LM1:
 147 0020 8091 D900 	 lds r24,217
 148 0024 887F      	 andi r24,lo8(-8)
 150               	.LM2:
 151 0026 883A      	 cpi r24,lo8(-88)
 152 0028 01F4      	 brne .+2
 153 002a 00C0      	 rjmp .L2
 154 002c 00F4      	 brsh .L3
 155 002e 8038      	 cpi r24,lo8(-128)
 156 0030 01F0      	 breq .L4
 157 0032 803A      	 cpi r24,lo8(-96)
 158 0034 01F4      	 brne .+2
 159 0036 00C0      	 rjmp .L5
 160 0038 8036      	 cpi r24,lo8(96)
 161 003a 01F0      	 breq .L6
 162               	.L1:
 163               	 
 219:main.c        **** 	/* SLA+W received, ACK returned -> receive data and ACK */
 220:main.c        **** 	case 0x60:
 221:main.c        **** 		bcnt = 0;
 222:main.c        **** 		LED_RT_ON();
 223:main.c        **** 		TWCR1 |= (1<<TWINT) | (1<<TWEA);
 224:main.c        **** 		break;
 225:main.c        **** 
 226:main.c        **** 	/* prev. SLA+W, data received, ACK returned -> receive data and ACK */
 227:main.c        **** 	case 0x80:
 228:main.c        **** 		data = TWDR1;
 229:main.c        **** 		switch (bcnt) {
 230:main.c        **** 		case 0:
 231:main.c        **** 			switch (data) {
 232:main.c        **** 			case CMD_SWITCH_APPLICATION:
 233:main.c        **** 			case CMD_WRITE_MEMORY:
 234:main.c        **** 				bcnt++;
 235:main.c        **** 				/* no break */
 236:main.c        **** 
 237:main.c        **** 			case CMD_WAIT:
 238:main.c        **** 				/* abort countdown */
 239:main.c        **** 				boot_timeout = 0;
 240:main.c        **** 				break;
 241:main.c        **** 
 242:main.c        **** 			default:
 243:main.c        **** 				/* boot app now */
 244:main.c        **** 				cmd = CMD_BOOT_APPLICATION;
 245:main.c        **** 				ack = (0<<TWEA);
 246:main.c        **** 				break;
 247:main.c        **** 			}
 248:main.c        **** 			cmd = data;
 249:main.c        **** 			break;
 250:main.c        **** 
 251:main.c        **** 		case 1:
 252:main.c        **** 			switch (cmd) {
 253:main.c        **** 			case CMD_SWITCH_APPLICATION:
 254:main.c        **** 				if (data == BOOTTYPE_APPLICATION) {
 255:main.c        **** 					cmd = CMD_BOOT_APPLICATION;
 256:main.c        **** 				}
 257:main.c        **** 				ack = (0<<TWEA);
 258:main.c        **** 				break;
 259:main.c        **** 
 260:main.c        **** 			case CMD_WRITE_MEMORY:
 261:main.c        **** 				bcnt++;
 262:main.c        **** 				if (data == MEMTYPE_CHIPINFO) {
 263:main.c        **** 					cmd = CMD_WRITE_CHIPINFO;
 264:main.c        **** 
 265:main.c        **** 				} else if (data == MEMTYPE_FLASH) {
 266:main.c        **** 					cmd = CMD_WRITE_FLASH;
 267:main.c        **** #if (EEPROM_SUPPORT)
 268:main.c        **** 				} else if (data == MEMTYPE_EEPROM) {
 269:main.c        **** 					cmd = CMD_WRITE_EEPROM;
 270:main.c        **** #endif
 271:main.c        **** 				} else {
 272:main.c        **** 					ack = (0<<TWEA);
 273:main.c        **** 				}
 274:main.c        **** 				break;
 275:main.c        **** 
 276:main.c        **** 			default:
 277:main.c        **** 				ack = (0<<TWEA);
 278:main.c        **** 				break;
 279:main.c        **** 			}
 280:main.c        **** 			break;
 281:main.c        **** 
 282:main.c        **** 		case 2:
 283:main.c        **** 		case 3:
 284:main.c        **** 			addr <<= 8;
 285:main.c        **** 			addr |= data;
 286:main.c        **** 			bcnt++;
 287:main.c        **** 			break;
 288:main.c        **** 
 289:main.c        **** 		default:
 290:main.c        **** 			switch (cmd) {
 291:main.c        **** 			case CMD_WRITE_FLASH:
 292:main.c        **** 				buf[bcnt -4] = data;
 293:main.c        **** 				if (bcnt < sizeof(buf) +3) {
 294:main.c        **** 					bcnt++;
 295:main.c        **** 				} else {
 296:main.c        **** 					write_flash_page();
 297:main.c        **** 					ack = (0<<TWEA);
 298:main.c        **** 				}
 299:main.c        **** 				break;
 300:main.c        **** #if (EEPROM_SUPPORT)
 301:main.c        **** 			case CMD_WRITE_EEPROM:
 302:main.c        **** 				write_eeprom_byte(data);
 303:main.c        **** 				bcnt++;
 304:main.c        **** 				break;
 305:main.c        **** #endif
 306:main.c        **** 			default:
 307:main.c        **** 				ack = (0<<TWEA);
 308:main.c        **** 				break;
 309:main.c        **** 			}
 310:main.c        **** 			break;
 311:main.c        **** 		}
 312:main.c        **** 
 313:main.c        **** 		if (ack == 0x00)
 314:main.c        **** 			bcnt = 0;
 315:main.c        **** 
 316:main.c        **** 		TWCR1 |= (1<<TWINT) | ack;
 317:main.c        **** 		break;
 318:main.c        **** 
 319:main.c        **** 	/* SLA+R received, ACK returned -> send data */
 320:main.c        **** 	case 0xA8:
 321:main.c        **** 		bcnt = 0;
 322:main.c        **** 		LED_RT_ON();
 323:main.c        **** 
 324:main.c        **** 	/* prev. SLA+R, data sent, ACK returned -> send data */
 325:main.c        **** 	case 0xB8:
 326:main.c        **** 		switch (cmd) {
 327:main.c        **** 		case CMD_READ_VERSION:
 328:main.c        **** 			data = info[bcnt++];
 329:main.c        **** 			bcnt %= sizeof(info);
 330:main.c        **** 			break;
 331:main.c        **** 
 332:main.c        **** 		case CMD_READ_CHIPINFO:
 333:main.c        **** 			data = chipinfo[bcnt++];
 334:main.c        **** 			bcnt %= sizeof(chipinfo);
 335:main.c        **** 			break;
 336:main.c        **** 
 337:main.c        **** 		case CMD_READ_FLASH:
 338:main.c        **** 			data = pgm_read_byte_near(addr++);
 339:main.c        **** 			break;
 340:main.c        **** #if (EEPROM_SUPPORT)
 341:main.c        **** 		case CMD_READ_EEPROM:
 342:main.c        **** 			data = read_eeprom_byte();
 343:main.c        **** 			break;
 344:main.c        **** #endif
 345:main.c        **** 		default:
 346:main.c        **** 			data = 0xFF;
 347:main.c        **** 			break;
 348:main.c        **** 		}
 349:main.c        **** 
 350:main.c        **** 		TWDR1 = data;
 351:main.c        **** 		TWCR1 |= (1<<TWINT) | (1<<TWEA);
 352:main.c        **** 		break;
 353:main.c        **** 
 354:main.c        **** 	/* STOP or repeated START */
 355:main.c        **** 	case 0xA0:
 356:main.c        **** 	/* data sent, NACK returned */
 357:main.c        **** 	case 0xC0:
 358:main.c        **** 		LED_RT_OFF();
 359:main.c        **** 		TWCR1 |= (1<<TWINT) | (1<<TWEA);
 360:main.c        **** 		break;
 361:main.c        **** 
 362:main.c        **** 	/* illegal state -> reset hardware */
 363:main.c        **** 	case 0xF8:
 364:main.c        **** 		TWCR1 |= (1<<TWINT) | (1<<TWSTO) | (1<<TWEA);
 365:main.c        **** 		break;
 366:main.c        **** 	}
 367:main.c        **** }
 165               	.LM3:
 166 003c FF91      	 pop r31
 167 003e EF91      	 pop r30
 168 0040 BF91      	 pop r27
 169 0042 AF91      	 pop r26
 170 0044 9F91      	 pop r25
 171 0046 8F91      	 pop r24
 172 0048 6F91      	 pop r22
 173 004a 5F91      	 pop r21
 174 004c 4F91      	 pop r20
 175 004e 3F91      	 pop r19
 176 0050 2F91 1F90 	 __gcc_isr 2
 176      0F90 0FBE 
 176      0F90 
 177 005a 1895      	 reti
 178               	.L3:
 218:main.c        **** 	/* SLA+W received, ACK returned -> receive data and ACK */
 180               	.LM4:
 181 005c 803C      	 cpi r24,lo8(-64)
 182 005e 01F4      	 brne .+2
 183 0060 00C0      	 rjmp .L5
 184 0062 883F      	 cpi r24,lo8(-8)
 185 0064 01F4      	 brne .+2
 186 0066 00C0      	 rjmp .L8
 187 0068 883B      	 cpi r24,lo8(-72)
 188 006a 01F4      	 brne .L1
 189               	.L9:
 326:main.c        **** 		case CMD_READ_VERSION:
 191               	.LM5:
 192 006c 8091 0000 	 lds r24,cmd
 193 0070 8232      	 cpi r24,lo8(34)
 194 0072 01F4      	 brne .+2
 195 0074 00C0      	 rjmp .L31
 196 0076 00F0      	 brlo .+2
 197 0078 00C0      	 rjmp .L32
 198 007a 8130      	 cpi r24,lo8(1)
 199 007c 01F4      	 brne .+2
 200 007e 00C0      	 rjmp .L33
 201 0080 8231      	 cpi r24,lo8(18)
 202 0082 01F4      	 brne .+2
 203 0084 00C0      	 rjmp .L34
 204               	.L58:
 205 0086 EFEF      	 ldi r30,lo8(-1)
 206               	.L35:
 350:main.c        **** 		TWCR1 |= (1<<TWINT) | (1<<TWEA);
 208               	.LM6:
 209 0088 E093 DB00 	 sts 219,r30
 210 008c 00C0      	 rjmp .L61
 211               	.L6:
 221:main.c        **** 		LED_RT_ON();
 213               	.LM7:
 214 008e 1092 0000 	 sts bcnt.2091,__zero_reg__
 215               	.LBB28:
 216               	.LBB29:
 217               	.LBB30:
 219               	.Ltext1:
   1:port.h        **** 
   2:port.h        **** 
   3:port.h        **** /**
   4:port.h        ****  * \file
   5:port.h        ****  *
   6:port.h        ****  * \brief Port
   7:port.h        ****  *
   8:port.h        ****  *
   9:port.h        ****  * Copyright (C) 2016 Atmel Corporation. All rights reserved.
  10:port.h        ****  *
  11:port.h        ****  * \asf_license_start
  12:port.h        ****  *
  13:port.h        ****  * \page License
  14:port.h        ****  *
  15:port.h        ****  * Redistribution and use in source and binary forms, with or without
  16:port.h        ****  * modification, are permitted provided that the following conditions are met:
  17:port.h        ****  *
  18:port.h        ****  * 1. Redistributions of source code must retain the above copyright notice,
  19:port.h        ****  *    this list of conditions and the following disclaimer.
  20:port.h        ****  *
  21:port.h        ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  22:port.h        ****  *    this list of conditions and the following disclaimer in the documentation
  23:port.h        ****  *    and/or other materials provided with the distribution.
  24:port.h        ****  *
  25:port.h        ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  26:port.h        ****  *    from this software without specific prior written permission.
  27:port.h        ****  *
  28:port.h        ****  * 4. This software may only be redistributed and used in connection with an
  29:port.h        ****  *    Atmel microcontroller product.
  30:port.h        ****  *
  31:port.h        ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  32:port.h        ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  33:port.h        ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  34:port.h        ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  35:port.h        ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  36:port.h        ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  37:port.h        ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  38:port.h        ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  39:port.h        ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  40:port.h        ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  41:port.h        ****  * POSSIBILITY OF SUCH DAMAGE.
  42:port.h        ****  *
  43:port.h        ****  * \asf_license_stop
  44:port.h        ****  *
  45:port.h        ****  *
  46:port.h        ****  */
  47:port.h        **** 
  48:port.h        **** #ifndef _PORT_INCLUDED_
  49:port.h        **** #define _PORT_INCLUDED_
  50:port.h        **** 
  51:port.h        **** #ifdef __cplusplus
  52:port.h        **** extern "C" {
  53:port.h        **** #endif
  54:port.h        **** 
  55:port.h        **** #include <stdint.h>
  56:port.h        **** #include <stdbool.h>
  57:port.h        **** #include <avr/io.h>
  58:port.h        **** 
  59:port.h        **** enum port_pull_mode {
  60:port.h        **** 	PORT_PULL_OFF,
  61:port.h        **** 	PORT_PULL_UP,
  62:port.h        **** };
  63:port.h        **** 
  64:port.h        **** enum port_dir {
  65:port.h        **** 	PORT_DIR_IN,
  66:port.h        **** 	PORT_DIR_OUT,
  67:port.h        **** 	PORT_DIR_OFF,
  68:port.h        **** };
  69:port.h        **** 
  70:port.h        **** /**
  71:port.h        ****  * \brief Set PORTB pin pull mode
  72:port.h        ****  *
  73:port.h        ****  * Configure pin to pull up, down or disable pull mode, supported pull
  74:port.h        ****  * modes are defined by device used
  75:port.h        ****  *
  76:port.h        ****  * \param[in] pin       The pin number in PORTB
  77:port.h        ****  * \param[in] pull_mode Pin pull mode
  78:port.h        ****  */
  79:port.h        **** static inline void PORTB_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
  80:port.h        **** {
  81:port.h        **** 
  82:port.h        **** 	if (pull_mode == PORT_PULL_UP) {
  83:port.h        **** 
  84:port.h        **** 		DDRB &= ~(1 << pin);
  85:port.h        **** 
  86:port.h        **** 		PORTB |= 1 << pin;
  87:port.h        **** 	} else if (pull_mode == PORT_PULL_OFF) {
  88:port.h        **** 
  89:port.h        **** 		PORTB &= ~(1 << pin);
  90:port.h        **** 	}
  91:port.h        **** }
  92:port.h        **** 
  93:port.h        **** /**
  94:port.h        ****  * \brief Set PORTB data direction
  95:port.h        ****  *
  96:port.h        ****  * Select if the port pins selected by mask data direction is input, output
  97:port.h        ****  * or disabled.
  98:port.h        ****  *
  99:port.h        ****  * \param[in] mask      Bit mask where 1 means apply direction setting to the
 100:port.h        ****  *                      corresponding pin
 101:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 102:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 103:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 104:port.h        ****  *                      (low power state)
 105:port.h        ****  */
 106:port.h        **** static inline void PORTB_set_port_dir(const uint8_t mask, const enum port_dir direction)
 107:port.h        **** {
 108:port.h        **** 	switch (direction) {
 109:port.h        **** 	case PORT_DIR_IN:
 110:port.h        **** 		DDRB &= ~mask;
 111:port.h        **** 		break;
 112:port.h        **** 	case PORT_DIR_OUT:
 113:port.h        **** 		DDRB |= mask;
 114:port.h        **** 		break;
 115:port.h        **** 	case PORT_DIR_OFF:
 116:port.h        **** 		DDRB &= ~mask;
 117:port.h        **** 
 118:port.h        **** 		PORTB |= mask;
 119:port.h        **** 		break;
 120:port.h        **** 	default:
 121:port.h        **** 		break;
 122:port.h        **** 	}
 123:port.h        **** }
 124:port.h        **** 
 125:port.h        **** /**
 126:port.h        ****  * \brief Set PORTB single pin data direction
 127:port.h        ****  *
 128:port.h        ****  * Select if the pin data direction is input, output or disabled.
 129:port.h        ****  * If disabled state is not possible, this function throws an assert.
 130:port.h        ****  *
 131:port.h        ****  * \param[in] pin       The pin number within PORTB (0..7)
 132:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 133:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 134:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 135:port.h        ****  *                      (low power state)
 136:port.h        ****  */
 137:port.h        **** static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir direction)
 138:port.h        **** {
 139:port.h        **** 	switch (direction) {
 140:port.h        **** 	case PORT_DIR_IN:
 141:port.h        **** 		DDRB &= ~(1 << pin);
 142:port.h        **** 		break;
 143:port.h        **** 	case PORT_DIR_OUT:
 144:port.h        **** 		DDRB |= 1 << pin;
 145:port.h        **** 		break;
 146:port.h        **** 	case PORT_DIR_OFF:
 147:port.h        **** 		DDRB |= ~(1 << pin);
 148:port.h        **** 
 149:port.h        **** 		PORTB |= 1 << pin;
 150:port.h        **** 		break;
 151:port.h        **** 	default:
 152:port.h        **** 		break;
 153:port.h        **** 	}
 154:port.h        **** }
 155:port.h        **** 
 156:port.h        **** /**
 157:port.h        ****  * \brief Set PORTB level
 158:port.h        ****  *
 159:port.h        ****  * Sets output level on the pins defined by the bit mask
 160:port.h        ****  *
 161:port.h        ****  * \param[in] mask  Bit mask where 1 means apply port level to the corresponding
 162:port.h        ****  *                  pin
 163:port.h        ****  * \param[in] level true  = Pin levels set to "high" state
 164:port.h        ****  *                  false = Pin levels set to "low" state
 165:port.h        ****  */
 166:port.h        **** static inline void PORTB_set_port_level(const uint8_t mask, const bool level)
 167:port.h        **** {
 168:port.h        **** 	if (level) {
 169:port.h        **** 		PORTB |= mask;
 170:port.h        **** 	} else {
 171:port.h        **** 		PORTB &= ~mask;
 172:port.h        **** 	}
 173:port.h        **** }
 174:port.h        **** 
 175:port.h        **** /**
 176:port.h        ****  * \brief Set PORTB level
 177:port.h        ****  *
 178:port.h        ****  * Sets output level on a pin
 179:port.h        ****  *
 180:port.h        ****  * \param[in] pin       The pin number for device
 181:port.h        ****  * \param[in] level true  = Pin level set to "high" state
 182:port.h        ****  *                  false = Pin level set to "low" state
 183:port.h        ****  */
 184:port.h        **** static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
 185:port.h        **** {
 186:port.h        **** 	if (level) {
 187:port.h        **** 		PORTB |= 1 << pin;
 188:port.h        **** 	} else {
 189:port.h        **** 		PORTB &= ~(1 << pin);
 190:port.h        **** 	}
 191:port.h        **** }
 192:port.h        **** 
 193:port.h        **** /**
 194:port.h        ****  * \brief Toggle out level on pins
 195:port.h        ****  *
 196:port.h        ****  * Toggle the pin levels on pins defined by bit mask
 197:port.h        ****  *
 198:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 199:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 200:port.h        ****  * \param[in] mask  Bit mask where 1 means toggle pin level to the corresponding
 201:port.h        ****  *                  pin
 202:port.h        ****  */
 203:port.h        **** static inline void PORTB_toggle_port_level(const uint8_t mask)
 204:port.h        **** {
 205:port.h        **** 	PINB = mask;
 206:port.h        **** }
 207:port.h        **** 
 208:port.h        **** /**
 209:port.h        ****  * \brief Toggle output level on pin
 210:port.h        ****  *
 211:port.h        ****  * Toggle the pin levels on pin
 212:port.h        ****  *
 213:port.h        ****  * \param[in] pin       The pin number for device
 214:port.h        ****  */
 215:port.h        **** static inline void PORTB_toggle_pin_level(const uint8_t pin)
 216:port.h        **** {
 217:port.h        **** 	PINB = 1 << pin;
 218:port.h        **** }
 219:port.h        **** 
 220:port.h        **** /**
 221:port.h        ****  * \brief Get input level on pins
 222:port.h        ****  *
 223:port.h        ****  * Read the input level on pins connected to a port
 224:port.h        ****  *
 225:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 226:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 227:port.h        ****  */
 228:port.h        **** static inline uint8_t PORTB_get_port_level(volatile uint8_t *port)
 229:port.h        **** {
 230:port.h        **** 	return PINB;
 231:port.h        **** }
 232:port.h        **** 
 233:port.h        **** /**
 234:port.h        ****  * \brief Get level on pin
 235:port.h        ****  *
 236:port.h        ****  * Reads the level on a pin connected to a port
 237:port.h        ****  *
 238:port.h        ****  * \param[in] pin       The pin number for device
 239:port.h        ****  */
 240:port.h        **** static inline bool PORTB_get_pin_level(const uint8_t pin)
 241:port.h        **** {
 242:port.h        **** 	return PINB & (1 << pin);
 243:port.h        **** }
 244:port.h        **** 
 245:port.h        **** /**
 246:port.h        ****  * \brief Write value to PORTB
 247:port.h        ****  *
 248:port.h        ****  * Write directly to the entire port register.
 249:port.h        ****  *
 250:port.h        ****  * \param[in] value   Value to write
 251:port.h        ****  */
 252:port.h        **** static inline void PORTB_write_port(const uint8_t value)
 253:port.h        **** {
 254:port.h        **** 	PORTB = value;
 255:port.h        **** }
 256:port.h        **** 
 257:port.h        **** /**
 258:port.h        ****  * \brief Set PORTC pin pull mode
 259:port.h        ****  *
 260:port.h        ****  * Configure pin to pull up, down or disable pull mode, supported pull
 261:port.h        ****  * modes are defined by device used
 262:port.h        ****  *
 263:port.h        ****  * \param[in] pin       The pin number in PORTC
 264:port.h        ****  * \param[in] pull_mode Pin pull mode
 265:port.h        ****  */
 266:port.h        **** static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
 267:port.h        **** {
 268:port.h        **** 
 269:port.h        **** 	if (pull_mode == PORT_PULL_UP) {
 270:port.h        **** 
 271:port.h        **** 		DDRC &= ~(1 << pin);
 272:port.h        **** 
 273:port.h        **** 		PORTC |= 1 << pin;
 274:port.h        **** 	} else if (pull_mode == PORT_PULL_OFF) {
 275:port.h        **** 
 276:port.h        **** 		PORTC &= ~(1 << pin);
 277:port.h        **** 	}
 278:port.h        **** }
 279:port.h        **** 
 280:port.h        **** /**
 281:port.h        ****  * \brief Set PORTC data direction
 282:port.h        ****  *
 283:port.h        ****  * Select if the port pins selected by mask data direction is input, output
 284:port.h        ****  * or disabled.
 285:port.h        ****  *
 286:port.h        ****  * \param[in] mask      Bit mask where 1 means apply direction setting to the
 287:port.h        ****  *                      corresponding pin
 288:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 289:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 290:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 291:port.h        ****  *                      (low power state)
 292:port.h        ****  */
 293:port.h        **** static inline void PORTC_set_port_dir(const uint8_t mask, const enum port_dir direction)
 294:port.h        **** {
 295:port.h        **** 	switch (direction) {
 296:port.h        **** 	case PORT_DIR_IN:
 297:port.h        **** 		DDRC &= ~mask;
 298:port.h        **** 		break;
 299:port.h        **** 	case PORT_DIR_OUT:
 300:port.h        **** 		DDRC |= mask;
 301:port.h        **** 		break;
 302:port.h        **** 	case PORT_DIR_OFF:
 303:port.h        **** 		DDRC &= ~mask;
 304:port.h        **** 
 305:port.h        **** 		PORTC |= mask;
 306:port.h        **** 		break;
 307:port.h        **** 	default:
 308:port.h        **** 		break;
 309:port.h        **** 	}
 310:port.h        **** }
 311:port.h        **** 
 312:port.h        **** /**
 313:port.h        ****  * \brief Set PORTC single pin data direction
 314:port.h        ****  *
 315:port.h        ****  * Select if the pin data direction is input, output or disabled.
 316:port.h        ****  * If disabled state is not possible, this function throws an assert.
 317:port.h        ****  *
 318:port.h        ****  * \param[in] pin       The pin number within PORTC (0..7)
 319:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 320:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 321:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 322:port.h        ****  *                      (low power state)
 323:port.h        ****  */
 324:port.h        **** static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir direction)
 325:port.h        **** {
 326:port.h        **** 	switch (direction) {
 327:port.h        **** 	case PORT_DIR_IN:
 328:port.h        **** 		DDRC &= ~(1 << pin);
 329:port.h        **** 		break;
 330:port.h        **** 	case PORT_DIR_OUT:
 331:port.h        **** 		DDRC |= 1 << pin;
 332:port.h        **** 		break;
 333:port.h        **** 	case PORT_DIR_OFF:
 334:port.h        **** 		DDRC |= ~(1 << pin);
 335:port.h        **** 
 336:port.h        **** 		PORTC |= 1 << pin;
 337:port.h        **** 		break;
 338:port.h        **** 	default:
 339:port.h        **** 		break;
 340:port.h        **** 	}
 341:port.h        **** }
 342:port.h        **** 
 343:port.h        **** /**
 344:port.h        ****  * \brief Set PORTC level
 345:port.h        ****  *
 346:port.h        ****  * Sets output level on the pins defined by the bit mask
 347:port.h        ****  *
 348:port.h        ****  * \param[in] mask  Bit mask where 1 means apply port level to the corresponding
 349:port.h        ****  *                  pin
 350:port.h        ****  * \param[in] level true  = Pin levels set to "high" state
 351:port.h        ****  *                  false = Pin levels set to "low" state
 352:port.h        ****  */
 353:port.h        **** static inline void PORTC_set_port_level(const uint8_t mask, const bool level)
 354:port.h        **** {
 355:port.h        **** 	if (level) {
 356:port.h        **** 		PORTC |= mask;
 357:port.h        **** 	} else {
 358:port.h        **** 		PORTC &= ~mask;
 359:port.h        **** 	}
 360:port.h        **** }
 361:port.h        **** 
 362:port.h        **** /**
 363:port.h        ****  * \brief Set PORTC level
 364:port.h        ****  *
 365:port.h        ****  * Sets output level on a pin
 366:port.h        ****  *
 367:port.h        ****  * \param[in] pin       The pin number for device
 368:port.h        ****  * \param[in] level true  = Pin level set to "high" state
 369:port.h        ****  *                  false = Pin level set to "low" state
 370:port.h        ****  */
 371:port.h        **** static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
 372:port.h        **** {
 373:port.h        **** 	if (level) {
 374:port.h        **** 		PORTC |= 1 << pin;
 375:port.h        **** 	} else {
 376:port.h        **** 		PORTC &= ~(1 << pin);
 377:port.h        **** 	}
 378:port.h        **** }
 379:port.h        **** 
 380:port.h        **** /**
 381:port.h        ****  * \brief Toggle out level on pins
 382:port.h        ****  *
 383:port.h        ****  * Toggle the pin levels on pins defined by bit mask
 384:port.h        ****  *
 385:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 386:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 387:port.h        ****  * \param[in] mask  Bit mask where 1 means toggle pin level to the corresponding
 388:port.h        ****  *                  pin
 389:port.h        ****  */
 390:port.h        **** static inline void PORTC_toggle_port_level(const uint8_t mask)
 391:port.h        **** {
 392:port.h        **** 	PINC = mask;
 393:port.h        **** }
 394:port.h        **** 
 395:port.h        **** /**
 396:port.h        ****  * \brief Toggle output level on pin
 397:port.h        ****  *
 398:port.h        ****  * Toggle the pin levels on pin
 399:port.h        ****  *
 400:port.h        ****  * \param[in] pin       The pin number for device
 401:port.h        ****  */
 402:port.h        **** static inline void PORTC_toggle_pin_level(const uint8_t pin)
 403:port.h        **** {
 404:port.h        **** 	PINC = 1 << pin;
 405:port.h        **** }
 406:port.h        **** 
 407:port.h        **** /**
 408:port.h        ****  * \brief Get input level on pins
 409:port.h        ****  *
 410:port.h        ****  * Read the input level on pins connected to a port
 411:port.h        ****  *
 412:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 413:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 414:port.h        ****  */
 415:port.h        **** static inline uint8_t PORTC_get_port_level(volatile uint8_t *port)
 416:port.h        **** {
 417:port.h        **** 	return PINC;
 418:port.h        **** }
 419:port.h        **** 
 420:port.h        **** /**
 421:port.h        ****  * \brief Get level on pin
 422:port.h        ****  *
 423:port.h        ****  * Reads the level on a pin connected to a port
 424:port.h        ****  *
 425:port.h        ****  * \param[in] pin       The pin number for device
 426:port.h        ****  */
 427:port.h        **** static inline bool PORTC_get_pin_level(const uint8_t pin)
 428:port.h        **** {
 429:port.h        **** 	return PINC & (1 << pin);
 430:port.h        **** }
 431:port.h        **** 
 432:port.h        **** /**
 433:port.h        ****  * \brief Write value to PORTC
 434:port.h        ****  *
 435:port.h        ****  * Write directly to the entire port register.
 436:port.h        ****  *
 437:port.h        ****  * \param[in] value   Value to write
 438:port.h        ****  */
 439:port.h        **** static inline void PORTC_write_port(const uint8_t value)
 440:port.h        **** {
 441:port.h        **** 	PORTC = value;
 442:port.h        **** }
 443:port.h        **** 
 444:port.h        **** /**
 445:port.h        ****  * \brief Set PORTD pin pull mode
 446:port.h        ****  *
 447:port.h        ****  * Configure pin to pull up, down or disable pull mode, supported pull
 448:port.h        ****  * modes are defined by device used
 449:port.h        ****  *
 450:port.h        ****  * \param[in] pin       The pin number in PORTD
 451:port.h        ****  * \param[in] pull_mode Pin pull mode
 452:port.h        ****  */
 453:port.h        **** static inline void PORTD_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
 454:port.h        **** {
 455:port.h        **** 
 456:port.h        **** 	if (pull_mode == PORT_PULL_UP) {
 457:port.h        **** 
 458:port.h        **** 		DDRD &= ~(1 << pin);
 459:port.h        **** 
 460:port.h        **** 		PORTD |= 1 << pin;
 461:port.h        **** 	} else if (pull_mode == PORT_PULL_OFF) {
 462:port.h        **** 
 463:port.h        **** 		PORTD &= ~(1 << pin);
 464:port.h        **** 	}
 465:port.h        **** }
 466:port.h        **** 
 467:port.h        **** /**
 468:port.h        ****  * \brief Set PORTD data direction
 469:port.h        ****  *
 470:port.h        ****  * Select if the port pins selected by mask data direction is input, output
 471:port.h        ****  * or disabled.
 472:port.h        ****  *
 473:port.h        ****  * \param[in] mask      Bit mask where 1 means apply direction setting to the
 474:port.h        ****  *                      corresponding pin
 475:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 476:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 477:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 478:port.h        ****  *                      (low power state)
 479:port.h        ****  */
 480:port.h        **** static inline void PORTD_set_port_dir(const uint8_t mask, const enum port_dir direction)
 481:port.h        **** {
 482:port.h        **** 	switch (direction) {
 483:port.h        **** 	case PORT_DIR_IN:
 484:port.h        **** 		DDRD &= ~mask;
 485:port.h        **** 		break;
 486:port.h        **** 	case PORT_DIR_OUT:
 487:port.h        **** 		DDRD |= mask;
 488:port.h        **** 		break;
 489:port.h        **** 	case PORT_DIR_OFF:
 490:port.h        **** 		DDRD &= ~mask;
 491:port.h        **** 
 492:port.h        **** 		PORTD |= mask;
 493:port.h        **** 		break;
 494:port.h        **** 	default:
 495:port.h        **** 		break;
 496:port.h        **** 	}
 497:port.h        **** }
 498:port.h        **** 
 499:port.h        **** /**
 500:port.h        ****  * \brief Set PORTD single pin data direction
 501:port.h        ****  *
 502:port.h        ****  * Select if the pin data direction is input, output or disabled.
 503:port.h        ****  * If disabled state is not possible, this function throws an assert.
 504:port.h        ****  *
 505:port.h        ****  * \param[in] pin       The pin number within PORTD (0..7)
 506:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 507:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 508:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 509:port.h        ****  *                      (low power state)
 510:port.h        ****  */
 511:port.h        **** static inline void PORTD_set_pin_dir(const uint8_t pin, const enum port_dir direction)
 512:port.h        **** {
 513:port.h        **** 	switch (direction) {
 514:port.h        **** 	case PORT_DIR_IN:
 515:port.h        **** 		DDRD &= ~(1 << pin);
 516:port.h        **** 		break;
 517:port.h        **** 	case PORT_DIR_OUT:
 518:port.h        **** 		DDRD |= 1 << pin;
 519:port.h        **** 		break;
 520:port.h        **** 	case PORT_DIR_OFF:
 521:port.h        **** 		DDRD |= ~(1 << pin);
 522:port.h        **** 
 523:port.h        **** 		PORTD |= 1 << pin;
 524:port.h        **** 		break;
 525:port.h        **** 	default:
 526:port.h        **** 		break;
 527:port.h        **** 	}
 528:port.h        **** }
 529:port.h        **** 
 530:port.h        **** /**
 531:port.h        ****  * \brief Set PORTD level
 532:port.h        ****  *
 533:port.h        ****  * Sets output level on the pins defined by the bit mask
 534:port.h        ****  *
 535:port.h        ****  * \param[in] mask  Bit mask where 1 means apply port level to the corresponding
 536:port.h        ****  *                  pin
 537:port.h        ****  * \param[in] level true  = Pin levels set to "high" state
 538:port.h        ****  *                  false = Pin levels set to "low" state
 539:port.h        ****  */
 540:port.h        **** static inline void PORTD_set_port_level(const uint8_t mask, const bool level)
 541:port.h        **** {
 542:port.h        **** 	if (level) {
 543:port.h        **** 		PORTD |= mask;
 544:port.h        **** 	} else {
 545:port.h        **** 		PORTD &= ~mask;
 546:port.h        **** 	}
 547:port.h        **** }
 548:port.h        **** 
 549:port.h        **** /**
 550:port.h        ****  * \brief Set PORTD level
 551:port.h        ****  *
 552:port.h        ****  * Sets output level on a pin
 553:port.h        ****  *
 554:port.h        ****  * \param[in] pin       The pin number for device
 555:port.h        ****  * \param[in] level true  = Pin level set to "high" state
 556:port.h        ****  *                  false = Pin level set to "low" state
 557:port.h        ****  */
 558:port.h        **** static inline void PORTD_set_pin_level(const uint8_t pin, const bool level)
 559:port.h        **** {
 560:port.h        **** 	if (level) {
 561:port.h        **** 		PORTD |= 1 << pin;
 562:port.h        **** 	} else {
 563:port.h        **** 		PORTD &= ~(1 << pin);
 564:port.h        **** 	}
 565:port.h        **** }
 566:port.h        **** 
 567:port.h        **** /**
 568:port.h        ****  * \brief Toggle out level on pins
 569:port.h        ****  *
 570:port.h        ****  * Toggle the pin levels on pins defined by bit mask
 571:port.h        ****  *
 572:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 573:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 574:port.h        ****  * \param[in] mask  Bit mask where 1 means toggle pin level to the corresponding
 575:port.h        ****  *                  pin
 576:port.h        ****  */
 577:port.h        **** static inline void PORTD_toggle_port_level(const uint8_t mask)
 578:port.h        **** {
 579:port.h        **** 	PIND = mask;
 580:port.h        **** }
 581:port.h        **** 
 582:port.h        **** /**
 583:port.h        ****  * \brief Toggle output level on pin
 584:port.h        ****  *
 585:port.h        ****  * Toggle the pin levels on pin
 586:port.h        ****  *
 587:port.h        ****  * \param[in] pin       The pin number for device
 588:port.h        ****  */
 589:port.h        **** static inline void PORTD_toggle_pin_level(const uint8_t pin)
 590:port.h        **** {
 591:port.h        **** 	PIND = 1 << pin;
 592:port.h        **** }
 593:port.h        **** 
 594:port.h        **** /**
 595:port.h        ****  * \brief Get input level on pins
 596:port.h        ****  *
 597:port.h        ****  * Read the input level on pins connected to a port
 598:port.h        ****  *
 599:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 600:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 601:port.h        ****  */
 602:port.h        **** static inline uint8_t PORTD_get_port_level(volatile uint8_t *port)
 603:port.h        **** {
 604:port.h        **** 	return PIND;
 605:port.h        **** }
 606:port.h        **** 
 607:port.h        **** /**
 608:port.h        ****  * \brief Get level on pin
 609:port.h        ****  *
 610:port.h        ****  * Reads the level on a pin connected to a port
 611:port.h        ****  *
 612:port.h        ****  * \param[in] pin       The pin number for device
 613:port.h        ****  */
 614:port.h        **** static inline bool PORTD_get_pin_level(const uint8_t pin)
 615:port.h        **** {
 616:port.h        **** 	return PIND & (1 << pin);
 617:port.h        **** }
 618:port.h        **** 
 619:port.h        **** /**
 620:port.h        ****  * \brief Write value to PORTD
 621:port.h        ****  *
 622:port.h        ****  * Write directly to the entire port register.
 623:port.h        ****  *
 624:port.h        ****  * \param[in] value   Value to write
 625:port.h        ****  */
 626:port.h        **** static inline void PORTD_write_port(const uint8_t value)
 627:port.h        **** {
 628:port.h        **** 	PORTD = value;
 629:port.h        **** }
 630:port.h        **** 
 631:port.h        **** /**
 632:port.h        ****  * \brief Set PORTE pin pull mode
 633:port.h        ****  *
 634:port.h        ****  * Configure pin to pull up, down or disable pull mode, supported pull
 635:port.h        ****  * modes are defined by device used
 636:port.h        ****  *
 637:port.h        ****  * \param[in] pin       The pin number in PORTE
 638:port.h        ****  * \param[in] pull_mode Pin pull mode
 639:port.h        ****  */
 640:port.h        **** static inline void PORTE_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
 641:port.h        **** {
 642:port.h        **** 
 643:port.h        **** 	if (pull_mode == PORT_PULL_UP) {
 644:port.h        **** 
 645:port.h        **** 		DDRE &= ~(1 << pin);
 646:port.h        **** 
 647:port.h        **** 		PORTE |= 1 << pin;
 648:port.h        **** 	} else if (pull_mode == PORT_PULL_OFF) {
 649:port.h        **** 
 650:port.h        **** 		PORTE &= ~(1 << pin);
 651:port.h        **** 	}
 652:port.h        **** }
 653:port.h        **** 
 654:port.h        **** /**
 655:port.h        ****  * \brief Set PORTE data direction
 656:port.h        ****  *
 657:port.h        ****  * Select if the port pins selected by mask data direction is input, output
 658:port.h        ****  * or disabled.
 659:port.h        ****  *
 660:port.h        ****  * \param[in] mask      Bit mask where 1 means apply direction setting to the
 661:port.h        ****  *                      corresponding pin
 662:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 663:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 664:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 665:port.h        ****  *                      (low power state)
 666:port.h        ****  */
 667:port.h        **** static inline void PORTE_set_port_dir(const uint8_t mask, const enum port_dir direction)
 668:port.h        **** {
 669:port.h        **** 	switch (direction) {
 670:port.h        **** 	case PORT_DIR_IN:
 671:port.h        **** 		DDRE &= ~mask;
 672:port.h        **** 		break;
 673:port.h        **** 	case PORT_DIR_OUT:
 674:port.h        **** 		DDRE |= mask;
 675:port.h        **** 		break;
 676:port.h        **** 	case PORT_DIR_OFF:
 677:port.h        **** 		DDRE &= ~mask;
 678:port.h        **** 
 679:port.h        **** 		PORTE |= mask;
 680:port.h        **** 		break;
 681:port.h        **** 	default:
 682:port.h        **** 		break;
 683:port.h        **** 	}
 684:port.h        **** }
 685:port.h        **** 
 686:port.h        **** /**
 687:port.h        ****  * \brief Set PORTE single pin data direction
 688:port.h        ****  *
 689:port.h        ****  * Select if the pin data direction is input, output or disabled.
 690:port.h        ****  * If disabled state is not possible, this function throws an assert.
 691:port.h        ****  *
 692:port.h        ****  * \param[in] pin       The pin number within PORTE (0..7)
 693:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 694:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 695:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 696:port.h        ****  *                      (low power state)
 697:port.h        ****  */
 698:port.h        **** static inline void PORTE_set_pin_dir(const uint8_t pin, const enum port_dir direction)
 699:port.h        **** {
 700:port.h        **** 	switch (direction) {
 701:port.h        **** 	case PORT_DIR_IN:
 702:port.h        **** 		DDRE &= ~(1 << pin);
 703:port.h        **** 		break;
 704:port.h        **** 	case PORT_DIR_OUT:
 705:port.h        **** 		DDRE |= 1 << pin;
 706:port.h        **** 		break;
 707:port.h        **** 	case PORT_DIR_OFF:
 708:port.h        **** 		DDRE |= ~(1 << pin);
 709:port.h        **** 
 710:port.h        **** 		PORTE |= 1 << pin;
 711:port.h        **** 		break;
 712:port.h        **** 	default:
 713:port.h        **** 		break;
 714:port.h        **** 	}
 715:port.h        **** }
 716:port.h        **** 
 717:port.h        **** /**
 718:port.h        ****  * \brief Set PORTE level
 719:port.h        ****  *
 720:port.h        ****  * Sets output level on the pins defined by the bit mask
 721:port.h        ****  *
 722:port.h        ****  * \param[in] mask  Bit mask where 1 means apply port level to the corresponding
 723:port.h        ****  *                  pin
 724:port.h        ****  * \param[in] level true  = Pin levels set to "high" state
 725:port.h        ****  *                  false = Pin levels set to "low" state
 726:port.h        ****  */
 727:port.h        **** static inline void PORTE_set_port_level(const uint8_t mask, const bool level)
 728:port.h        **** {
 729:port.h        **** 	if (level) {
 730:port.h        **** 		PORTE |= mask;
 731:port.h        **** 	} else {
 732:port.h        **** 		PORTE &= ~mask;
 733:port.h        **** 	}
 734:port.h        **** }
 735:port.h        **** 
 736:port.h        **** /**
 737:port.h        ****  * \brief Set PORTE level
 738:port.h        ****  *
 739:port.h        ****  * Sets output level on a pin
 740:port.h        ****  *
 741:port.h        ****  * \param[in] pin       The pin number for device
 742:port.h        ****  * \param[in] level true  = Pin level set to "high" state
 743:port.h        ****  *                  false = Pin level set to "low" state
 744:port.h        ****  */
 745:port.h        **** static inline void PORTE_set_pin_level(const uint8_t pin, const bool level)
 746:port.h        **** {
 747:port.h        **** 	if (level) {
 748:port.h        **** 		PORTE |= 1 << pin;
 749:port.h        **** 	} else {
 750:port.h        **** 		PORTE &= ~(1 << pin);
 221               	.LM8:
 222 0092 7398      	 cbi 0xe,3
 223               	.L61:
 224               	.LBE30:
 225               	.LBE29:
 226               	.LBE28:
 228               	.Ltext2:
 359:main.c        **** 		break;
 230               	.LM9:
 231 0094 8091 DC00 	 lds r24,220
 232 0098 806C      	 ori r24,lo8(-64)
 233 009a 00C0      	 rjmp .L59
 234               	.L4:
 228:main.c        **** 		switch (bcnt) {
 236               	.LM10:
 237 009c 8091 DB00 	 lds r24,219
 229:main.c        **** 		case 0:
 239               	.LM11:
 240 00a0 9091 0000 	 lds r25,bcnt.2091
 241 00a4 9130      	 cpi r25,lo8(1)
 242 00a6 01F4      	 brne .+2
 243 00a8 00C0      	 rjmp .L10
 244 00aa 00F0      	 brlo .L11
 245 00ac 2EEF      	 ldi r18,lo8(-2)
 246 00ae 290F      	 add r18,r25
 247 00b0 2230      	 cpi r18,lo8(2)
 248 00b2 00F4      	 brsh .+2
 249 00b4 00C0      	 rjmp .L53
 290:main.c        **** 			case CMD_WRITE_FLASH:
 251               	.LM12:
 252 00b6 2091 0000 	 lds r18,cmd
 253 00ba 2232      	 cpi r18,lo8(34)
 254 00bc 01F4      	 brne .+2
 255 00be 00C0      	 rjmp .L24
 256 00c0 2233      	 cpi r18,lo8(50)
 257 00c2 01F4      	 brne .L17
 258               	.LBB31:
 259               	.LBB32:
 200:main.c        **** 	EEARH = (addr >> 8);
 261               	.LM13:
 262 00c4 9091 0000 	 lds r25,addr
 263 00c8 91BD      	 out 0x21,r25
 201:main.c        **** 	EEDR = val;
 265               	.LM14:
 266 00ca 9091 0000 	 lds r25,addr+1
 201:main.c        **** 	EEDR = val;
 268               	.LM15:
 269 00ce 92BD      	 out 0x22,r25
 202:main.c        **** 	addr++;
 271               	.LM16:
 272 00d0 80BD      	 out 0x20,r24
 203:main.c        **** 
 274               	.LM17:
 275 00d2 8091 0000 	 lds r24,addr
 276 00d6 9091 0000 	 lds r25,addr+1
 277 00da 0196      	 adiw r24,1
 278 00dc 9093 0000 	 sts addr+1,r25
 279 00e0 8093 0000 	 sts addr,r24
 205:main.c        **** 	EECR |= (1<<EEPE);
 281               	.LM18:
 282 00e4 FA9A      	 sbi 0x1f,2
 206:main.c        **** 
 284               	.LM19:
 285 00e6 F99A      	 sbi 0x1f,1
 286               	.L30:
 208:main.c        **** }
 288               	.LM20:
 289 00e8 F999      	 sbic 0x1f,1
 290 00ea 00C0      	 rjmp .L30
 291               	.LBE32:
 292               	.LBE31:
 303:main.c        **** 				break;
 294               	.LM21:
 295 00ec 8091 0000 	 lds r24,bcnt.2091
 296 00f0 8F5F      	 subi r24,lo8(-(1))
 297 00f2 8093 0000 	 sts bcnt.2091,r24
 298 00f6 00C0      	 rjmp .L56
 299               	.L11:
 300 00f8 8823      	 tst r24
 301 00fa 01F0      	 breq .L14
 302 00fc 9FEF      	 ldi r25,lo8(-1)
 303 00fe 980F      	 add r25,r24
 304 0100 9230      	 cpi r25,lo8(2)
 305 0102 00F4      	 brsh .L15
 234:main.c        **** 				/* no break */
 307               	.LM22:
 308 0104 91E0      	 ldi r25,lo8(1)
 309 0106 9093 0000 	 sts bcnt.2091,r25
 310               	.L14:
 239:main.c        **** 				break;
 312               	.LM23:
 313 010a 1092 0000 	 sts boot_timeout,__zero_reg__
 314               	.L55:
 269:main.c        **** #endif
 316               	.LM24:
 317 010e 8093 0000 	 sts cmd,r24
 318               	.L56:
 216:main.c        **** 
 320               	.LM25:
 321 0112 80E4      	 ldi r24,lo8(64)
 322               	.L16:
 316:main.c        **** 		break;
 324               	.LM26:
 325 0114 9091 DC00 	 lds r25,220
 326 0118 892B      	 or r24,r25
 327 011a 8068      	 ori r24,lo8(-128)
 328               	.L59:
 364:main.c        **** 		break;
 330               	.LM27:
 331 011c 8093 DC00 	 sts 220,r24
 333               	.LM28:
 334 0120 00C0      	 rjmp .L1
 335               	.L15:
 244:main.c        **** 				ack = (0<<TWEA);
 337               	.LM29:
 338 0122 91E2      	 ldi r25,lo8(33)
 339 0124 9093 0000 	 sts cmd,r25
 340               	.L54:
 255:main.c        **** 				}
 342               	.LM30:
 343 0128 8093 0000 	 sts cmd,r24
 344 012c 00C0      	 rjmp .L17
 345               	.L10:
 252:main.c        **** 			case CMD_SWITCH_APPLICATION:
 347               	.LM31:
 348 012e 9091 0000 	 lds r25,cmd
 349 0132 9130      	 cpi r25,lo8(1)
 350 0134 01F0      	 breq .L18
 351 0136 9230      	 cpi r25,lo8(2)
 352 0138 01F0      	 breq .L19
 353               	.L17:
 314:main.c        **** 
 355               	.LM32:
 356 013a 1092 0000 	 sts bcnt.2091,__zero_reg__
 357 013e 80E0      	 ldi r24,0
 358 0140 00C0      	 rjmp .L16
 359               	.L18:
 254:main.c        **** 					cmd = CMD_BOOT_APPLICATION;
 361               	.LM33:
 362 0142 8038      	 cpi r24,lo8(-128)
 363 0144 01F4      	 brne .L17
 255:main.c        **** 				}
 365               	.LM34:
 366 0146 81E2      	 ldi r24,lo8(33)
 367 0148 00C0      	 rjmp .L54
 368               	.L19:
 261:main.c        **** 				if (data == MEMTYPE_CHIPINFO) {
 370               	.LM35:
 371 014a 9093 0000 	 sts bcnt.2091,r25
 262:main.c        **** 					cmd = CMD_WRITE_CHIPINFO;
 373               	.LM36:
 374 014e 8111      	 cpse r24,__zero_reg__
 375 0150 00C0      	 rjmp .L21
 263:main.c        **** 
 377               	.LM37:
 378 0152 82E1      	 ldi r24,lo8(18)
 379 0154 00C0      	 rjmp .L55
 380               	.L21:
 265:main.c        **** 					cmd = CMD_WRITE_FLASH;
 382               	.LM38:
 383 0156 8130      	 cpi r24,lo8(1)
 384 0158 01F4      	 brne .L22
 266:main.c        **** #if (EEPROM_SUPPORT)
 386               	.LM39:
 387 015a 82E2      	 ldi r24,lo8(34)
 388 015c 00C0      	 rjmp .L55
 389               	.L22:
 268:main.c        **** 					cmd = CMD_WRITE_EEPROM;
 391               	.LM40:
 392 015e 8230      	 cpi r24,lo8(2)
 393 0160 01F4      	 brne .L17
 269:main.c        **** #endif
 395               	.LM41:
 396 0162 82E3      	 ldi r24,lo8(50)
 397 0164 00C0      	 rjmp .L55
 398               	.L53:
 284:main.c        **** 			addr |= data;
 400               	.LM42:
 401 0166 20E0      	 ldi r18,0
 402 0168 3091 0000 	 lds r19,addr
 285:main.c        **** 			bcnt++;
 404               	.LM43:
 405 016c 282B      	 or r18,r24
 406 016e 3093 0000 	 sts addr+1,r19
 407 0172 2093 0000 	 sts addr,r18
 408               	.L60:
 294:main.c        **** 				} else {
 410               	.LM44:
 411 0176 9F5F      	 subi r25,lo8(-(1))
 412 0178 9093 0000 	 sts bcnt.2091,r25
 413 017c 00C0      	 rjmp .L56
 414               	.L24:
 229:main.c        **** 		case 0:
 416               	.LM45:
 417 017e E92F      	 mov r30,r25
 418 0180 F0E0      	 ldi r31,0
 292:main.c        **** 				if (bcnt < sizeof(buf) +3) {
 420               	.LM46:
 421 0182 E050      	 subi r30,lo8(-(buf-4))
 422 0184 F040      	 sbci r31,hi8(-(buf-4))
 423 0186 8083      	 st Z,r24
 293:main.c        **** 					bcnt++;
 425               	.LM47:
 426 0188 9338      	 cpi r25,lo8(-125)
 427 018a 00F0      	 brlo .L60
 428               	.LBB33:
 429               	.LBB34:
 163:main.c        **** 	uint8_t size = SPM_PAGESIZE;
 431               	.LM48:
 432 018c 8091 0000 	 lds r24,addr
 433 0190 9091 0000 	 lds r25,addr+1
 168:main.c        **** 		return;
 435               	.LM49:
 436 0194 8115      	 cp r24,__zero_reg__
 437 0196 28E7      	 ldi r18,120
 438 0198 9207      	 cpc r25,r18
 439 019a 00F4      	 brsh .L17
 171:main.c        **** 	boot_spm_busy_wait();
 441               	.LM50:
 442 019c 23E0      	 ldi r18,lo8(3)
 443 019e FC01      	 movw r30,r24
 444               	 
 445               	 
 446 01a0 2093 5700 	 sts 87,r18
 447 01a4 E895      	 spm
 448               	 
 449               	 
 450               	 
 451               	.L27:
 172:main.c        **** 
 453               	.LM51:
 454 01a6 07B6      	 in __tmp_reg__,0x37
 455 01a8 00FC      	 sbrc __tmp_reg__,0
 456 01aa 00C0      	 rjmp .L27
 457 01ac A0E0      	 ldi r26,lo8(buf)
 458 01ae B0E0      	 ldi r27,hi8(buf)
 459 01b0 40E0      	 ldi r20,lo8(buf+128)
 460 01b2 50E0      	 ldi r21,hi8(buf+128)
 461 01b4 FC01      	 movw r30,r24
 462               	.LBB35:
 177:main.c        **** 
 464               	.LM52:
 465 01b6 61E0      	 ldi r22,lo8(1)
 466               	.L28:
 175:main.c        **** 		data |= *p++ << 8;
 468               	.LM53:
 469 01b8 2C91      	 ld r18,X
 176:main.c        **** 		boot_page_fill(addr, data);
 471               	.LM54:
 472 01ba 1196      	 adiw r26,1
 473 01bc 3C91      	 ld r19,X
 474 01be 1197      	 sbiw r26,1
 177:main.c        **** 
 476               	.LM55:
 477               	 
 478               	 
 479 01c0 0901      	 movw r0,r18
 480 01c2 6093 5700 	 sts 87,r22
 481 01c6 E895      	 spm
 482 01c8 1124      	 clr r1
 483               	 
 484               	 
 485               	 
 486 01ca 3296      	 adiw r30,2
 487 01cc 1296      	 adiw r26,2
 488               	.LBE35:
 181:main.c        **** 
 490               	.LM56:
 491 01ce 4A17      	 cp r20,r26
 492 01d0 5B07      	 cpc r21,r27
 493 01d2 01F4      	 brne .L28
 494 01d4 9C01      	 movw r18,r24
 495 01d6 2058      	 subi r18,-128
 496 01d8 3F4F      	 sbci r19,-1
 497 01da 3093 0000 	 sts addr+1,r19
 498 01de 2093 0000 	 sts addr,r18
 183:main.c        **** 	boot_spm_busy_wait();
 500               	.LM57:
 501 01e2 25E0      	 ldi r18,lo8(5)
 502 01e4 FC01      	 movw r30,r24
 503               	 
 504               	 
 505 01e6 2093 5700 	 sts 87,r18
 506 01ea E895      	 spm
 507               	 
 508               	 
 509               	 
 510               	.L29:
 184:main.c        **** 	boot_rww_enable();
 512               	.LM58:
 513 01ec 07B6      	 in __tmp_reg__,0x37
 514 01ee 00FC      	 sbrc __tmp_reg__,0
 515 01f0 00C0      	 rjmp .L29
 185:main.c        **** }
 517               	.LM59:
 518 01f2 81E1      	 ldi r24,lo8(17)
 519               	 
 520               	 
 521 01f4 8093 5700 	 sts 87,r24
 522 01f8 E895      	 spm
 523               	 
 524               	 
 525               	 
 526 01fa 00C0      	 rjmp .L17
 527               	.L2:
 528               	.LBE34:
 529               	.LBE33:
 321:main.c        **** 		LED_RT_ON();
 531               	.LM60:
 532 01fc 1092 0000 	 sts bcnt.2091,__zero_reg__
 533               	.LBB36:
 534               	.LBB37:
 535               	.LBB38:
 537               	.Ltext3:
 539               	.LM61:
 540 0200 7398      	 cbi 0xe,3
 541 0202 00C0      	 rjmp .L9
 542               	.L32:
 543               	.LBE38:
 544               	.LBE37:
 545               	.LBE36:
 546 0204 8233      	 cpi r24,lo8(50)
 547 0206 01F0      	 breq .+2
 548 0208 00C0      	 rjmp .L58
 549               	.LBB39:
 550               	.LBB40:
 552               	.Ltext4:
 191:main.c        **** 	EEARH = (addr >> 8);
 554               	.LM62:
 555 020a 8091 0000 	 lds r24,addr
 556 020e 81BD      	 out 0x21,r24
 192:main.c        **** 	EECR |= (1<<EERE);
 558               	.LM63:
 559 0210 8091 0000 	 lds r24,addr+1
 192:main.c        **** 	EECR |= (1<<EERE);
 561               	.LM64:
 562 0214 82BD      	 out 0x22,r24
 193:main.c        **** 	addr++;
 564               	.LM65:
 565 0216 F89A      	 sbi 0x1f,0
 194:main.c        **** 	return EEDR;
 567               	.LM66:
 568 0218 8091 0000 	 lds r24,addr
 569 021c 9091 0000 	 lds r25,addr+1
 570 0220 0196      	 adiw r24,1
 571 0222 9093 0000 	 sts addr+1,r25
 572 0226 8093 0000 	 sts addr,r24
 195:main.c        **** }
 574               	.LM67:
 575 022a E0B5      	 in r30,0x20
 576               	.LBE40:
 577               	.LBE39:
 343:main.c        **** #endif
 579               	.LM68:
 580 022c 00C0      	 rjmp .L35
 581               	.L33:
 328:main.c        **** 			bcnt %= sizeof(info);
 583               	.LM69:
 584 022e 8091 0000 	 lds r24,bcnt.2091
 585 0232 E82F      	 mov r30,r24
 586 0234 F0E0      	 ldi r31,0
 328:main.c        **** 			bcnt %= sizeof(info);
 588               	.LM70:
 589 0236 E050      	 subi r30,lo8(-(info))
 590 0238 F040      	 sbci r31,hi8(-(info))
 591 023a E081      	 ld r30,Z
 328:main.c        **** 			bcnt %= sizeof(info);
 593               	.LM71:
 594 023c 8F5F      	 subi r24,lo8(-(1))
 329:main.c        **** 			break;
 596               	.LM72:
 597 023e 8F70      	 andi r24,lo8(15)
 598               	.L57:
 334:main.c        **** 			break;
 600               	.LM73:
 601 0240 8093 0000 	 sts bcnt.2091,r24
 335:main.c        **** 
 603               	.LM74:
 604 0244 00C0      	 rjmp .L35
 605               	.L34:
 333:main.c        **** 			bcnt %= sizeof(chipinfo);
 607               	.LM75:
 608 0246 8091 0000 	 lds r24,bcnt.2091
 609 024a E82F      	 mov r30,r24
 610 024c F0E0      	 ldi r31,0
 333:main.c        **** 			bcnt %= sizeof(chipinfo);
 612               	.LM76:
 613 024e E050      	 subi r30,lo8(-(chipinfo))
 614 0250 F040      	 sbci r31,hi8(-(chipinfo))
 615 0252 E081      	 ld r30,Z
 333:main.c        **** 			bcnt %= sizeof(chipinfo);
 617               	.LM77:
 618 0254 8F5F      	 subi r24,lo8(-(1))
 334:main.c        **** 			break;
 620               	.LM78:
 621 0256 8770      	 andi r24,lo8(7)
 622 0258 00C0      	 rjmp .L57
 623               	.L31:
 624               	.LBB41:
 338:main.c        **** 			break;
 626               	.LM79:
 627 025a E091 0000 	 lds r30,addr
 628 025e F091 0000 	 lds r31,addr+1
 629 0262 CF01      	 movw r24,r30
 630 0264 0196      	 adiw r24,1
 631 0266 9093 0000 	 sts addr+1,r25
 632 026a 8093 0000 	 sts addr,r24
 633               	 
 634               	 
 635 026e E491      	 lpm r30,Z
 636               	 
 637               	 
 638               	 
 639               	.LBE41:
 339:main.c        **** #if (EEPROM_SUPPORT)
 641               	.LM80:
 642 0270 00C0      	 rjmp .L35
 643               	.L5:
 644               	.LBB42:
 645               	.LBB43:
 646               	.LBB44:
 648               	.Ltext5:
 748:port.h        **** 	} else {
 650               	.LM81:
 651 0272 739A      	 sbi 0xe,3
 652 0274 00C0      	 rjmp .L61
 653               	.L8:
 654               	.LBE44:
 655               	.LBE43:
 656               	.LBE42:
 658               	.Ltext6:
 364:main.c        **** 		break;
 660               	.LM82:
 661 0276 8091 DC00 	 lds r24,220
 662 027a 806D      	 ori r24,lo8(-48)
 663 027c 00C0      	 rjmp .L59
 664               	 __gcc_isr 0,r18
 676               	.Lscope1:
 678               	 .stabd 78,0,0
 679               	 .section .text.__vector_16,"ax",@progbits
 681               	.global __vector_16
 683               	__vector_16:
 684               	 .stabd 46,0,0
 368:main.c        **** 
 369:main.c        **** ISR(TIMER0_OVF_vect)
 370:main.c        **** {
 686               	.LM83:
 687               	.LFBB2:
 688 0000 8F93 8FB7 	 __gcc_isr 1
 688      8F93 
 689               	 
 690               	 
 691               	 
 692               	.L__stack_usage =0+__gcc_isr.n_pushed
 371:main.c        **** 	/* restart timer */
 372:main.c        **** 	TCNT0 = TIMER_RELOAD;
 694               	.LM84:
 695 0006 8CE3      	 ldi r24,lo8(60)
 696 0008 86BD      	 out 0x26,r24
 697               	.LBB45:
 698               	.LBB46:
 699               	.LBB47:
 701               	.Ltext7:
 751:port.h        **** 	}
 752:port.h        **** }
 753:port.h        **** 
 754:port.h        **** /**
 755:port.h        ****  * \brief Toggle out level on pins
 756:port.h        ****  *
 757:port.h        ****  * Toggle the pin levels on pins defined by bit mask
 758:port.h        ****  *
 759:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 760:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 761:port.h        ****  * \param[in] mask  Bit mask where 1 means toggle pin level to the corresponding
 762:port.h        ****  *                  pin
 763:port.h        ****  */
 764:port.h        **** static inline void PORTE_toggle_port_level(const uint8_t mask)
 765:port.h        **** {
 766:port.h        **** 	PINE = mask;
 767:port.h        **** }
 768:port.h        **** 
 769:port.h        **** /**
 770:port.h        ****  * \brief Toggle output level on pin
 771:port.h        ****  *
 772:port.h        ****  * Toggle the pin levels on pin
 773:port.h        ****  *
 774:port.h        ****  * \param[in] pin       The pin number for device
 775:port.h        ****  */
 776:port.h        **** static inline void PORTE_toggle_pin_level(const uint8_t pin)
 777:port.h        **** {
 778:port.h        **** 	PINE = 1 << pin;
 703               	.LM85:
 704 000a 88E0      	 ldi r24,lo8(8)
 705 000c 8CB9      	 out 0xc,r24
 706               	.LBE47:
 707               	.LBE46:
 708               	.LBE45:
 710               	.Ltext8:
 373:main.c        **** 
 374:main.c        **** 	/* blink LED while running */
 375:main.c        **** 	LED_GN_TOGGLE();
 376:main.c        **** 	
 377:main.c        **** 
 378:main.c        **** 	/* count down for app-boot */
 379:main.c        **** 	if (boot_timeout > 1)
 712               	.LM86:
 713 000e 8091 0000 	 lds r24,boot_timeout
 715               	.LM87:
 716 0012 8230      	 cpi r24,lo8(2)
 717 0014 00F0      	 brlo .L63
 380:main.c        **** 		boot_timeout--;
 719               	.LM88:
 720 0016 8150      	 subi r24,lo8(-(-1))
 721 0018 8093 0000 	 sts boot_timeout,r24
 722               	.L62:
 723               	 
 381:main.c        **** 
 382:main.c        **** 	/* trigger app-boot */
 383:main.c        **** 	else if (boot_timeout == 1)
 384:main.c        **** 		cmd = CMD_BOOT_APPLICATION;
 385:main.c        **** }
 725               	.LM89:
 726 001c 8F91 8FBF 	 __gcc_isr 2
 726      8F91 
 727 0022 1895      	 reti
 728               	.L63:
 383:main.c        **** 		cmd = CMD_BOOT_APPLICATION;
 730               	.LM90:
 731 0024 8130      	 cpi r24,lo8(1)
 732 0026 01F4      	 brne .L62
 384:main.c        **** }
 734               	.LM91:
 735 0028 81E2      	 ldi r24,lo8(33)
 736 002a 8093 0000 	 sts cmd,r24
 738               	.LM92:
 739 002e 00C0      	 rjmp .L62
 740               	 __gcc_isr 0,r24
 742               	.Lscope2:
 744               	 .stabd 78,0,0
 745               	 .section .init3,"ax",@progbits
 747               	.global disable_wdt_timer
 749               	disable_wdt_timer:
 750               	 .stabd 46,0,0
 386:main.c        **** 
 387:main.c        **** static void (*jump_to_app)(void) __attribute__ ((noreturn)) = 0x0000;
 388:main.c        **** 
 389:main.c        **** /*
 390:main.c        ****  * For newer devices (mega88) the watchdog timer remains active even after a
 391:main.c        ****  * system reset. So disable it as soon as possible.
 392:main.c        ****  * automagically called on startup
 393:main.c        ****  */
 394:main.c        **** #if defined (__AVR_ATmega328PB__)
 395:main.c        **** void disable_wdt_timer(void) __attribute__((naked, section(".init3")));
 396:main.c        **** void disable_wdt_timer(void)
 397:main.c        **** {
 752               	.LM93:
 753               	.LFBB3:
 754               	 
 755               	 
 756               	 
 757               	.L__stack_usage =0
 398:main.c        **** 	MCUSR = 0;
 759               	.LM94:
 760 0000 14BE      	 out 0x34,__zero_reg__
 399:main.c        **** 	WDTCSR = (1<<WDCE) | (1<<WDE);
 762               	.LM95:
 763 0002 E0E6      	 ldi r30,lo8(96)
 764 0004 F0E0      	 ldi r31,0
 765 0006 88E1      	 ldi r24,lo8(24)
 766 0008 8083      	 st Z,r24
 400:main.c        **** 	WDTCSR = (0<<WDE);
 768               	.LM96:
 769 000a 1082      	 st Z,__zero_reg__
 770               	 
 401:main.c        **** }
 772               	.LM97:
 774               	.Lscope3:
 776               	 .stabd 78,0,0
 777               	 .section .text.startup.main,"ax",@progbits
 779               	.global main
 781               	main:
 782               	 .stabd 46,0,0
 402:main.c        **** #endif 
 403:main.c        **** 
 404:main.c        **** int main(void) __attribute__ ((noreturn));
 405:main.c        **** int main(void)
 406:main.c        **** {
 784               	.LM98:
 785               	.LFBB4:
 786               	 
 787               	 
 788               	 
 789               	.L__stack_usage =0
 407:main.c        ****     port_init();
 791               	.LM99:
 792 0000 0E94 0000 	 call port_init
 793               	.LBB60:
 794               	.LBB61:
 795               	.LBB62:
 797               	.Ltext9:
 705:port.h        **** 		break;
 799               	.LM100:
 800 0004 6B9A      	 sbi 0xd,3
 801               	.LBE62:
 802               	.LBE61:
 803               	.LBE60:
 804               	.LBB63:
 805               	.LBB64:
 806               	.LBB65:
 750:port.h        **** 	}
 808               	.LM101:
 809 0006 7398      	 cbi 0xe,3
 810               	.LBE65:
 811               	.LBE64:
 812               	.LBE63:
 814               	.Ltext10:
 408:main.c        **** 
 409:main.c        **** 	LED_INIT();
 410:main.c        **** 	LED_GN_ON();
 411:main.c        **** 
 412:main.c        **** 	/* move interrupt-vectors to bootloader */
 413:main.c        **** 	/* timer0: running with F_CPU/1024, OVF interrupt */
 414:main.c        **** 	MCUCR = (1<<IVCE);
 816               	.LM102:
 817 0008 81E0      	 ldi r24,lo8(1)
 818 000a 85BF      	 out 0x35,r24
 415:main.c        **** 	MCUCR = (1<<IVSEL);
 820               	.LM103:
 821 000c 92E0      	 ldi r25,lo8(2)
 822 000e 95BF      	 out 0x35,r25
 416:main.c        **** 
 417:main.c        **** 	TCCR0B = (1<<CS02) | (1<<CS00);
 824               	.LM104:
 825 0010 95E0      	 ldi r25,lo8(5)
 826 0012 95BD      	 out 0x25,r25
 418:main.c        **** 	TIMSK0 = (1<<TOIE0);
 828               	.LM105:
 829 0014 8093 6E00 	 sts 110,r24
 419:main.c        **** 
 420:main.c        **** 	/* TWI init: set address, auto ACKs with interrupts */
 421:main.c        **** 	TWAR1 = (TWI_ADDRESS<<1);
 831               	.LM106:
 832 0018 80E1      	 ldi r24,lo8(16)
 833 001a 8093 DA00 	 sts 218,r24
 422:main.c        **** 	TWCR1 = (1<<TWEA) | (1<<TWEN) | (1<<TWIE);
 835               	.LM107:
 836 001e 85E4      	 ldi r24,lo8(69)
 837 0020 8093 DC00 	 sts 220,r24
 423:main.c        **** 
 424:main.c        **** 	sei();
 839               	.LM108:
 840               	 
 841               	 
 842 0024 7894      	 sei
 843               	 
 844               	 
 845               	.L67:
 425:main.c        **** 	while (cmd != CMD_BOOT_APPLICATION);
 847               	.LM109:
 848 0026 8091 0000 	 lds r24,cmd
 850               	.LM110:
 851 002a 8132      	 cpi r24,lo8(33)
 852 002c 01F4      	 brne .L67
 426:main.c        **** 
 427:main.c        **** 	cli();
 854               	.LM111:
 855               	 
 856               	 
 857 002e F894      	 cli
 858               	 
 428:main.c        **** 
 429:main.c        **** 	/* Disable TWI but keep address! */
 430:main.c        **** 	TWCR1 = 0x00;
 860               	.LM112:
 861               	 
 862 0030 1092 DC00 	 sts 220,__zero_reg__
 431:main.c        **** 
 432:main.c        **** 	/* disable timer0 */
 433:main.c        **** 	/* move interrupt vectors back to application */
 434:main.c        **** 	TIMSK0 = 0x00;
 864               	.LM113:
 865 0034 1092 6E00 	 sts 110,__zero_reg__
 435:main.c        **** 	TCCR0B = 0x00;
 867               	.LM114:
 868 0038 15BC      	 out 0x25,__zero_reg__
 436:main.c        **** 
 437:main.c        **** 	MCUCR = (1<<IVCE);
 870               	.LM115:
 871 003a 81E0      	 ldi r24,lo8(1)
 872 003c 85BF      	 out 0x35,r24
 438:main.c        **** 	MCUCR = (0<<IVSEL);
 874               	.LM116:
 875 003e 15BE      	 out 0x35,__zero_reg__
 876               	.LBB66:
 877               	.LBB67:
 878               	.LBB68:
 880               	.Ltext11:
 748:port.h        **** 	} else {
 882               	.LM117:
 883 0040 739A      	 sbi 0xe,3
 884               	.LBE68:
 885               	.LBE67:
 886               	.LBE66:
 888               	.Ltext12:
 439:main.c        **** 
 440:main.c        **** 	LED_OFF();
 441:main.c        **** 
 442:main.c        **** 	uint16_t wait = 0x0000;
 890               	.LM118:
 891 0042 F0E0      	 ldi r31,0
 892 0044 E0E0      	 ldi r30,0
 893               	.L68:
 443:main.c        **** 	do {
 444:main.c        **** 		__asm volatile ("nop");
 895               	.LM119:
 896               	 
 897               	 
 898 0046 0000      	 nop
 899               	 
 445:main.c        **** 	} while (--wait);
 901               	.LM120:
 902               	 
 903 0048 3197      	 sbiw r30,1
 904 004a 01F4      	 brne .L68
 446:main.c        **** 
 447:main.c        **** 	jump_to_app();
 906               	.LM121:
 907 004c 0995      	 icall
 912               	.Lscope4:
 914               	 .stabd 78,0,0
 915               	 .section .bss.bcnt.2091,"aw",@nobits
 918               	bcnt.2091:
 919 0000 00        	 .zero 1
 921               	 .section .bss.addr,"aw",@nobits
 924               	addr:
 925 0000 0000      	 .zero 2
 927               	 .section .bss.buf,"aw",@nobits
 930               	buf:
 931 0000 0000 0000 	 .zero 128
 931      0000 0000 
 931      0000 0000 
 931      0000 0000 
 931      0000 0000 
 933               	 .section .bss.cmd,"aw",@nobits
 936               	cmd:
 937 0000 00        	 .zero 1
 939               	 .section .data.boot_timeout,"aw"
 942               	boot_timeout:
 943 0000 28        	 .byte 40
 945               	 .section .rodata.chipinfo,"a"
 948               	chipinfo:
 949 0000 1E95 1680 	 .string "\036\225\026\200x"
 949      7800 
 950 0006 0400      	 .string "\004"
 952               	 .section .rodata.info,"a"
 955               	info:
 956 0000 4B4C 424F 	 .string "KLBOOT328PBv2.1"
 956      4F54 3332 
 956      3850 4276 
 956      322E 3100 
 958               	 .text
 960               	.Letext0:
 961               	 .ident "GCC: (GNU) 9.1.0"
 962               	.global __do_copy_data
 963               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
    {standard input}:2      *ABS*:000000000000003e __SP_H__
    {standard input}:3      *ABS*:000000000000003d __SP_L__
    {standard input}:4      *ABS*:000000000000003f __SREG__
    {standard input}:5      *ABS*:0000000000000000 __tmp_reg__
    {standard input}:6      *ABS*:0000000000000001 __zero_reg__
    {standard input}:125    .text.__vector_40:0000000000000000 __vector_40
                            *ABS*:0000000000000004 __gcc_isr.n_pushed.001
    {standard input}:936    .bss.cmd:0000000000000000 cmd
    {standard input}:918    .bss.bcnt.2091:0000000000000000 bcnt.2091
    {standard input}:924    .bss.addr:0000000000000000 addr
    {standard input}:942    .data.boot_timeout:0000000000000000 boot_timeout
    {standard input}:930    .bss.buf:0000000000000000 buf
    {standard input}:955    .rodata.info:0000000000000000 info
    {standard input}:948    .rodata.chipinfo:0000000000000000 chipinfo
    {standard input}:683    .text.__vector_16:0000000000000000 __vector_16
                            *ABS*:0000000000000002 __gcc_isr.n_pushed.002
    {standard input}:749    .init3:0000000000000000 disable_wdt_timer
    {standard input}:781    .text.startup.main:0000000000000000 main

UNDEFINED SYMBOLS
port_init
__do_copy_data
__do_clear_bss
