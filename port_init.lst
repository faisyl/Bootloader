   1               	 .file "port_init.c"
   2               	__SP_H__ =0x3e
   3               	__SP_L__ =0x3d
   4               	__SREG__ =0x3f
   5               	__tmp_reg__ =0
   6               	__zero_reg__ =1
   9               	 .text
  10               	.Ltext0:
 111               	 .section .text.I2C_0_initialization,"ax",@progbits
 113               	.global I2C_0_initialization
 115               	I2C_0_initialization:
 116               	 .stabd 46,0,0
   1:port_init.c   **** /**
   2:port_init.c   ****  * \file
   3:port_init.c   ****  *
   4:port_init.c   ****  * \brief Driver initialization.
   5:port_init.c   ****  *
   6:port_init.c   ****  *
   7:port_init.c   ****  * Copyright (C) 2016 Atmel Corporation. All rights reserved.
   8:port_init.c   ****  *
   9:port_init.c   ****  * \asf_license_start
  10:port_init.c   ****  *
  11:port_init.c   ****  * \page License
  12:port_init.c   ****  *
  13:port_init.c   ****  * Redistribution and use in source and binary forms, with or without
  14:port_init.c   ****  * modification, are permitted provided that the following conditions are met:
  15:port_init.c   ****  *
  16:port_init.c   ****  * 1. Redistributions of source code must retain the above copyright notice,
  17:port_init.c   ****  *    this list of conditions and the following disclaimer.
  18:port_init.c   ****  *
  19:port_init.c   ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  20:port_init.c   ****  *    this list of conditions and the following disclaimer in the documentation
  21:port_init.c   ****  *    and/or other materials provided with the distribution.
  22:port_init.c   ****  *
  23:port_init.c   ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  24:port_init.c   ****  *    from this software without specific prior written permission.
  25:port_init.c   ****  *
  26:port_init.c   ****  * 4. This software may only be redistributed and used in connection with an
  27:port_init.c   ****  *    Atmel microcontroller product.
  28:port_init.c   ****  *
  29:port_init.c   ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  30:port_init.c   ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  31:port_init.c   ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  32:port_init.c   ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  33:port_init.c   ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  34:port_init.c   ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  35:port_init.c   ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  36:port_init.c   ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  37:port_init.c   ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  38:port_init.c   ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  39:port_init.c   ****  * POSSIBILITY OF SUCH DAMAGE.
  40:port_init.c   ****  *
  41:port_init.c   ****  * \asf_license_stop
  42:port_init.c   ****  *
  43:port_init.c   ****  *
  44:port_init.c   ****  */
  45:port_init.c   **** 
  46:port_init.c   **** /*
  47:port_init.c   ****  * Code generated by START.
  48:port_init.c   ****  *
  49:port_init.c   ****  * This file will be overwritten when reconfiguring your START project.
  50:port_init.c   ****  * Please copy examples or other code you want to keep to a separate file
  51:port_init.c   ****  * to avoid losing it when reconfiguring.
  52:port_init.c   ****  */
  53:port_init.c   **** 
  54:port_init.c   **** #include "port_init.h"
  55:port_init.c   **** 
  56:port_init.c   **** /* configure pins and initialize registers */
  57:port_init.c   **** void I2C_0_initialization(void)
  58:port_init.c   **** {
 118               	.LM0:
 119               	.LFBB1:
 120               	 
 121               	 
 122               	 
 123               	.L__stack_usage =0
 124               	.LBB34:
 125               	.LBB35:
 126               	.LBB36:
 128               	.Ltext1:
   1:port.h        **** 
   2:port.h        **** 
   3:port.h        **** /**
   4:port.h        ****  * \file
   5:port.h        ****  *
   6:port.h        ****  * \brief Port
   7:port.h        ****  *
   8:port.h        ****  *
   9:port.h        ****  * Copyright (C) 2016 Atmel Corporation. All rights reserved.
  10:port.h        ****  *
  11:port.h        ****  * \asf_license_start
  12:port.h        ****  *
  13:port.h        ****  * \page License
  14:port.h        ****  *
  15:port.h        ****  * Redistribution and use in source and binary forms, with or without
  16:port.h        ****  * modification, are permitted provided that the following conditions are met:
  17:port.h        ****  *
  18:port.h        ****  * 1. Redistributions of source code must retain the above copyright notice,
  19:port.h        ****  *    this list of conditions and the following disclaimer.
  20:port.h        ****  *
  21:port.h        ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  22:port.h        ****  *    this list of conditions and the following disclaimer in the documentation
  23:port.h        ****  *    and/or other materials provided with the distribution.
  24:port.h        ****  *
  25:port.h        ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  26:port.h        ****  *    from this software without specific prior written permission.
  27:port.h        ****  *
  28:port.h        ****  * 4. This software may only be redistributed and used in connection with an
  29:port.h        ****  *    Atmel microcontroller product.
  30:port.h        ****  *
  31:port.h        ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  32:port.h        ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  33:port.h        ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  34:port.h        ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  35:port.h        ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  36:port.h        ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  37:port.h        ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  38:port.h        ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  39:port.h        ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  40:port.h        ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  41:port.h        ****  * POSSIBILITY OF SUCH DAMAGE.
  42:port.h        ****  *
  43:port.h        ****  * \asf_license_stop
  44:port.h        ****  *
  45:port.h        ****  *
  46:port.h        ****  */
  47:port.h        **** 
  48:port.h        **** #ifndef _PORT_INCLUDED_
  49:port.h        **** #define _PORT_INCLUDED_
  50:port.h        **** 
  51:port.h        **** #ifdef __cplusplus
  52:port.h        **** extern "C" {
  53:port.h        **** #endif
  54:port.h        **** 
  55:port.h        **** #include <stdint.h>
  56:port.h        **** #include <stdbool.h>
  57:port.h        **** #include <avr/io.h>
  58:port.h        **** 
  59:port.h        **** enum port_pull_mode {
  60:port.h        **** 	PORT_PULL_OFF,
  61:port.h        **** 	PORT_PULL_UP,
  62:port.h        **** };
  63:port.h        **** 
  64:port.h        **** enum port_dir {
  65:port.h        **** 	PORT_DIR_IN,
  66:port.h        **** 	PORT_DIR_OUT,
  67:port.h        **** 	PORT_DIR_OFF,
  68:port.h        **** };
  69:port.h        **** 
  70:port.h        **** /**
  71:port.h        ****  * \brief Set PORTB pin pull mode
  72:port.h        ****  *
  73:port.h        ****  * Configure pin to pull up, down or disable pull mode, supported pull
  74:port.h        ****  * modes are defined by device used
  75:port.h        ****  *
  76:port.h        ****  * \param[in] pin       The pin number in PORTB
  77:port.h        ****  * \param[in] pull_mode Pin pull mode
  78:port.h        ****  */
  79:port.h        **** static inline void PORTB_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
  80:port.h        **** {
  81:port.h        **** 
  82:port.h        **** 	if (pull_mode == PORT_PULL_UP) {
  83:port.h        **** 
  84:port.h        **** 		DDRB &= ~(1 << pin);
  85:port.h        **** 
  86:port.h        **** 		PORTB |= 1 << pin;
  87:port.h        **** 	} else if (pull_mode == PORT_PULL_OFF) {
  88:port.h        **** 
  89:port.h        **** 		PORTB &= ~(1 << pin);
  90:port.h        **** 	}
  91:port.h        **** }
  92:port.h        **** 
  93:port.h        **** /**
  94:port.h        ****  * \brief Set PORTB data direction
  95:port.h        ****  *
  96:port.h        ****  * Select if the port pins selected by mask data direction is input, output
  97:port.h        ****  * or disabled.
  98:port.h        ****  *
  99:port.h        ****  * \param[in] mask      Bit mask where 1 means apply direction setting to the
 100:port.h        ****  *                      corresponding pin
 101:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 102:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 103:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 104:port.h        ****  *                      (low power state)
 105:port.h        ****  */
 106:port.h        **** static inline void PORTB_set_port_dir(const uint8_t mask, const enum port_dir direction)
 107:port.h        **** {
 108:port.h        **** 	switch (direction) {
 109:port.h        **** 	case PORT_DIR_IN:
 110:port.h        **** 		DDRB &= ~mask;
 111:port.h        **** 		break;
 112:port.h        **** 	case PORT_DIR_OUT:
 113:port.h        **** 		DDRB |= mask;
 114:port.h        **** 		break;
 115:port.h        **** 	case PORT_DIR_OFF:
 116:port.h        **** 		DDRB &= ~mask;
 117:port.h        **** 
 118:port.h        **** 		PORTB |= mask;
 119:port.h        **** 		break;
 120:port.h        **** 	default:
 121:port.h        **** 		break;
 122:port.h        **** 	}
 123:port.h        **** }
 124:port.h        **** 
 125:port.h        **** /**
 126:port.h        ****  * \brief Set PORTB single pin data direction
 127:port.h        ****  *
 128:port.h        ****  * Select if the pin data direction is input, output or disabled.
 129:port.h        ****  * If disabled state is not possible, this function throws an assert.
 130:port.h        ****  *
 131:port.h        ****  * \param[in] pin       The pin number within PORTB (0..7)
 132:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 133:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 134:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 135:port.h        ****  *                      (low power state)
 136:port.h        ****  */
 137:port.h        **** static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir direction)
 138:port.h        **** {
 139:port.h        **** 	switch (direction) {
 140:port.h        **** 	case PORT_DIR_IN:
 141:port.h        **** 		DDRB &= ~(1 << pin);
 142:port.h        **** 		break;
 143:port.h        **** 	case PORT_DIR_OUT:
 144:port.h        **** 		DDRB |= 1 << pin;
 145:port.h        **** 		break;
 146:port.h        **** 	case PORT_DIR_OFF:
 147:port.h        **** 		DDRB |= ~(1 << pin);
 148:port.h        **** 
 149:port.h        **** 		PORTB |= 1 << pin;
 150:port.h        **** 		break;
 151:port.h        **** 	default:
 152:port.h        **** 		break;
 153:port.h        **** 	}
 154:port.h        **** }
 155:port.h        **** 
 156:port.h        **** /**
 157:port.h        ****  * \brief Set PORTB level
 158:port.h        ****  *
 159:port.h        ****  * Sets output level on the pins defined by the bit mask
 160:port.h        ****  *
 161:port.h        ****  * \param[in] mask  Bit mask where 1 means apply port level to the corresponding
 162:port.h        ****  *                  pin
 163:port.h        ****  * \param[in] level true  = Pin levels set to "high" state
 164:port.h        ****  *                  false = Pin levels set to "low" state
 165:port.h        ****  */
 166:port.h        **** static inline void PORTB_set_port_level(const uint8_t mask, const bool level)
 167:port.h        **** {
 168:port.h        **** 	if (level) {
 169:port.h        **** 		PORTB |= mask;
 170:port.h        **** 	} else {
 171:port.h        **** 		PORTB &= ~mask;
 172:port.h        **** 	}
 173:port.h        **** }
 174:port.h        **** 
 175:port.h        **** /**
 176:port.h        ****  * \brief Set PORTB level
 177:port.h        ****  *
 178:port.h        ****  * Sets output level on a pin
 179:port.h        ****  *
 180:port.h        ****  * \param[in] pin       The pin number for device
 181:port.h        ****  * \param[in] level true  = Pin level set to "high" state
 182:port.h        ****  *                  false = Pin level set to "low" state
 183:port.h        ****  */
 184:port.h        **** static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
 185:port.h        **** {
 186:port.h        **** 	if (level) {
 187:port.h        **** 		PORTB |= 1 << pin;
 188:port.h        **** 	} else {
 189:port.h        **** 		PORTB &= ~(1 << pin);
 190:port.h        **** 	}
 191:port.h        **** }
 192:port.h        **** 
 193:port.h        **** /**
 194:port.h        ****  * \brief Toggle out level on pins
 195:port.h        ****  *
 196:port.h        ****  * Toggle the pin levels on pins defined by bit mask
 197:port.h        ****  *
 198:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 199:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 200:port.h        ****  * \param[in] mask  Bit mask where 1 means toggle pin level to the corresponding
 201:port.h        ****  *                  pin
 202:port.h        ****  */
 203:port.h        **** static inline void PORTB_toggle_port_level(const uint8_t mask)
 204:port.h        **** {
 205:port.h        **** 	PINB = mask;
 206:port.h        **** }
 207:port.h        **** 
 208:port.h        **** /**
 209:port.h        ****  * \brief Toggle output level on pin
 210:port.h        ****  *
 211:port.h        ****  * Toggle the pin levels on pin
 212:port.h        ****  *
 213:port.h        ****  * \param[in] pin       The pin number for device
 214:port.h        ****  */
 215:port.h        **** static inline void PORTB_toggle_pin_level(const uint8_t pin)
 216:port.h        **** {
 217:port.h        **** 	PINB = 1 << pin;
 218:port.h        **** }
 219:port.h        **** 
 220:port.h        **** /**
 221:port.h        ****  * \brief Get input level on pins
 222:port.h        ****  *
 223:port.h        ****  * Read the input level on pins connected to a port
 224:port.h        ****  *
 225:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 226:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 227:port.h        ****  */
 228:port.h        **** static inline uint8_t PORTB_get_port_level(volatile uint8_t *port)
 229:port.h        **** {
 230:port.h        **** 	return PINB;
 231:port.h        **** }
 232:port.h        **** 
 233:port.h        **** /**
 234:port.h        ****  * \brief Get level on pin
 235:port.h        ****  *
 236:port.h        ****  * Reads the level on a pin connected to a port
 237:port.h        ****  *
 238:port.h        ****  * \param[in] pin       The pin number for device
 239:port.h        ****  */
 240:port.h        **** static inline bool PORTB_get_pin_level(const uint8_t pin)
 241:port.h        **** {
 242:port.h        **** 	return PINB & (1 << pin);
 243:port.h        **** }
 244:port.h        **** 
 245:port.h        **** /**
 246:port.h        ****  * \brief Write value to PORTB
 247:port.h        ****  *
 248:port.h        ****  * Write directly to the entire port register.
 249:port.h        ****  *
 250:port.h        ****  * \param[in] value   Value to write
 251:port.h        ****  */
 252:port.h        **** static inline void PORTB_write_port(const uint8_t value)
 253:port.h        **** {
 254:port.h        **** 	PORTB = value;
 255:port.h        **** }
 256:port.h        **** 
 257:port.h        **** /**
 258:port.h        ****  * \brief Set PORTC pin pull mode
 259:port.h        ****  *
 260:port.h        ****  * Configure pin to pull up, down or disable pull mode, supported pull
 261:port.h        ****  * modes are defined by device used
 262:port.h        ****  *
 263:port.h        ****  * \param[in] pin       The pin number in PORTC
 264:port.h        ****  * \param[in] pull_mode Pin pull mode
 265:port.h        ****  */
 266:port.h        **** static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
 267:port.h        **** {
 268:port.h        **** 
 269:port.h        **** 	if (pull_mode == PORT_PULL_UP) {
 270:port.h        **** 
 271:port.h        **** 		DDRC &= ~(1 << pin);
 272:port.h        **** 
 273:port.h        **** 		PORTC |= 1 << pin;
 274:port.h        **** 	} else if (pull_mode == PORT_PULL_OFF) {
 275:port.h        **** 
 276:port.h        **** 		PORTC &= ~(1 << pin);
 277:port.h        **** 	}
 278:port.h        **** }
 279:port.h        **** 
 280:port.h        **** /**
 281:port.h        ****  * \brief Set PORTC data direction
 282:port.h        ****  *
 283:port.h        ****  * Select if the port pins selected by mask data direction is input, output
 284:port.h        ****  * or disabled.
 285:port.h        ****  *
 286:port.h        ****  * \param[in] mask      Bit mask where 1 means apply direction setting to the
 287:port.h        ****  *                      corresponding pin
 288:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 289:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 290:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 291:port.h        ****  *                      (low power state)
 292:port.h        ****  */
 293:port.h        **** static inline void PORTC_set_port_dir(const uint8_t mask, const enum port_dir direction)
 294:port.h        **** {
 295:port.h        **** 	switch (direction) {
 296:port.h        **** 	case PORT_DIR_IN:
 297:port.h        **** 		DDRC &= ~mask;
 298:port.h        **** 		break;
 299:port.h        **** 	case PORT_DIR_OUT:
 300:port.h        **** 		DDRC |= mask;
 301:port.h        **** 		break;
 302:port.h        **** 	case PORT_DIR_OFF:
 303:port.h        **** 		DDRC &= ~mask;
 304:port.h        **** 
 305:port.h        **** 		PORTC |= mask;
 306:port.h        **** 		break;
 307:port.h        **** 	default:
 308:port.h        **** 		break;
 309:port.h        **** 	}
 310:port.h        **** }
 311:port.h        **** 
 312:port.h        **** /**
 313:port.h        ****  * \brief Set PORTC single pin data direction
 314:port.h        ****  *
 315:port.h        ****  * Select if the pin data direction is input, output or disabled.
 316:port.h        ****  * If disabled state is not possible, this function throws an assert.
 317:port.h        ****  *
 318:port.h        ****  * \param[in] pin       The pin number within PORTC (0..7)
 319:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 320:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 321:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 322:port.h        ****  *                      (low power state)
 323:port.h        ****  */
 324:port.h        **** static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir direction)
 325:port.h        **** {
 326:port.h        **** 	switch (direction) {
 327:port.h        **** 	case PORT_DIR_IN:
 328:port.h        **** 		DDRC &= ~(1 << pin);
 329:port.h        **** 		break;
 330:port.h        **** 	case PORT_DIR_OUT:
 331:port.h        **** 		DDRC |= 1 << pin;
 130               	.LM1:
 131 0000 3D9A      	 sbi 0x7,5
 132               	.LBE36:
 133               	.LBE35:
 134               	.LBE34:
 135               	.LBB37:
 136               	.LBB38:
 137               	.LBB39:
 138               	.LBB40:
 276:port.h        **** 	}
 140               	.LM2:
 141 0002 4598      	 cbi 0x8,5
 142               	.LBE40:
 143               	.LBE39:
 144               	.LBE38:
 145               	.LBE37:
 146               	.LBB41:
 147               	.LBB42:
 148               	.LBB43:
 149               	.LBB44:
 150 0004 4598      	 cbi 0x8,5
 151               	.LBE44:
 152               	.LBE43:
 153               	.LBE42:
 154               	.LBE41:
 155               	.LBB45:
 156               	.LBB46:
 157               	.LBB47:
 159               	.LM3:
 160 0006 3C9A      	 sbi 0x7,4
 161               	.LBE47:
 162               	.LBE46:
 163               	.LBE45:
 164               	.LBB48:
 165               	.LBB49:
 166               	.LBB50:
 167               	.LBB51:
 276:port.h        **** 	}
 169               	.LM4:
 170 0008 4498      	 cbi 0x8,4
 171               	.LBE51:
 172               	.LBE50:
 173               	.LBE49:
 174               	.LBE48:
 175               	.LBB52:
 176               	.LBB53:
 177               	.LBB54:
 178               	.LBB55:
 179 000a 4498      	 cbi 0x8,4
 180               	 
 181               	.LBE55:
 182               	.LBE54:
 183               	.LBE53:
 184               	.LBE52:
 186               	.Ltext2:
  59:port_init.c   **** 
  60:port_init.c   **** 	PC5_set_dir(
  61:port_init.c   **** 	    // <y> Pin direction
  62:port_init.c   **** 	    // <id> pad_dir
  63:port_init.c   **** 	    // <PORT_DIR_OFF"> Off
  64:port_init.c   **** 	    // <PORT_DIR_IN"> In
  65:port_init.c   **** 	    // <PORT_DIR_OUT"> Out
  66:port_init.c   **** 	    PORT_DIR_OUT);
  67:port_init.c   **** 
  68:port_init.c   **** 	PC5_set_level(
  69:port_init.c   **** 	    // <y> Initial level
  70:port_init.c   **** 	    // <id> pad_initial_level
  71:port_init.c   **** 	    // <false"> Low
  72:port_init.c   **** 	    // <true"> High
  73:port_init.c   **** 	    false);
  74:port_init.c   **** 
  75:port_init.c   **** 	PC5_set_pull_mode(
  76:port_init.c   **** 	    // <y> Pull configuration
  77:port_init.c   **** 	    // <id> pad_pull_config
  78:port_init.c   **** 	    // <PORT_PULL_OFF"> Off
  79:port_init.c   **** 	    // <PORT_PULL_UP"> Pull-up
  80:port_init.c   **** 	    PORT_PULL_OFF);
  81:port_init.c   **** 
  82:port_init.c   **** 	PC4_set_dir(
  83:port_init.c   **** 	    // <y> Pin direction
  84:port_init.c   **** 	    // <id> pad_dir
  85:port_init.c   **** 	    // <PORT_DIR_OFF"> Off
  86:port_init.c   **** 	    // <PORT_DIR_IN"> In
  87:port_init.c   **** 	    // <PORT_DIR_OUT"> Out
  88:port_init.c   **** 	    PORT_DIR_OUT);
  89:port_init.c   **** 
  90:port_init.c   **** 	PC4_set_level(
  91:port_init.c   **** 	    // <y> Initial level
  92:port_init.c   **** 	    // <id> pad_initial_level
  93:port_init.c   **** 	    // <false"> Low
  94:port_init.c   **** 	    // <true"> High
  95:port_init.c   **** 	    false);
  96:port_init.c   **** 
  97:port_init.c   **** 	PC4_set_pull_mode(
  98:port_init.c   **** 	    // <y> Pull configuration
  99:port_init.c   **** 	    // <id> pad_pull_config
 100:port_init.c   **** 	    // <PORT_PULL_OFF"> Off
 101:port_init.c   **** 	    // <PORT_PULL_UP"> Pull-up
 102:port_init.c   **** 	    PORT_PULL_OFF);
 103:port_init.c   **** 
 104:port_init.c   **** }
 188               	.LM5:
 189 000c 0895      	 ret
 191               	.Lscope1:
 193               	 .stabd 78,0,0
 194               	 .section .text.I2C_1_initialization,"ax",@progbits
 196               	.global I2C_1_initialization
 198               	I2C_1_initialization:
 199               	 .stabd 46,0,0
 105:port_init.c   **** 
 106:port_init.c   **** /* configure pins and initialize registers */
 107:port_init.c   **** void I2C_1_initialization(void)
 108:port_init.c   **** {
 201               	.LM6:
 202               	.LFBB2:
 203               	 
 204               	 
 205               	 
 206               	.L__stack_usage =0
 207               	.LBB76:
 208               	.LBB77:
 209               	.LBB78:
 211               	.Ltext3:
 332:port.h        **** 		break;
 333:port.h        **** 	case PORT_DIR_OFF:
 334:port.h        **** 		DDRC |= ~(1 << pin);
 335:port.h        **** 
 336:port.h        **** 		PORTC |= 1 << pin;
 337:port.h        **** 		break;
 338:port.h        **** 	default:
 339:port.h        **** 		break;
 340:port.h        **** 	}
 341:port.h        **** }
 342:port.h        **** 
 343:port.h        **** /**
 344:port.h        ****  * \brief Set PORTC level
 345:port.h        ****  *
 346:port.h        ****  * Sets output level on the pins defined by the bit mask
 347:port.h        ****  *
 348:port.h        ****  * \param[in] mask  Bit mask where 1 means apply port level to the corresponding
 349:port.h        ****  *                  pin
 350:port.h        ****  * \param[in] level true  = Pin levels set to "high" state
 351:port.h        ****  *                  false = Pin levels set to "low" state
 352:port.h        ****  */
 353:port.h        **** static inline void PORTC_set_port_level(const uint8_t mask, const bool level)
 354:port.h        **** {
 355:port.h        **** 	if (level) {
 356:port.h        **** 		PORTC |= mask;
 357:port.h        **** 	} else {
 358:port.h        **** 		PORTC &= ~mask;
 359:port.h        **** 	}
 360:port.h        **** }
 361:port.h        **** 
 362:port.h        **** /**
 363:port.h        ****  * \brief Set PORTC level
 364:port.h        ****  *
 365:port.h        ****  * Sets output level on a pin
 366:port.h        ****  *
 367:port.h        ****  * \param[in] pin       The pin number for device
 368:port.h        ****  * \param[in] level true  = Pin level set to "high" state
 369:port.h        ****  *                  false = Pin level set to "low" state
 370:port.h        ****  */
 371:port.h        **** static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
 372:port.h        **** {
 373:port.h        **** 	if (level) {
 374:port.h        **** 		PORTC |= 1 << pin;
 375:port.h        **** 	} else {
 376:port.h        **** 		PORTC &= ~(1 << pin);
 377:port.h        **** 	}
 378:port.h        **** }
 379:port.h        **** 
 380:port.h        **** /**
 381:port.h        ****  * \brief Toggle out level on pins
 382:port.h        ****  *
 383:port.h        ****  * Toggle the pin levels on pins defined by bit mask
 384:port.h        ****  *
 385:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 386:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 387:port.h        ****  * \param[in] mask  Bit mask where 1 means toggle pin level to the corresponding
 388:port.h        ****  *                  pin
 389:port.h        ****  */
 390:port.h        **** static inline void PORTC_toggle_port_level(const uint8_t mask)
 391:port.h        **** {
 392:port.h        **** 	PINC = mask;
 393:port.h        **** }
 394:port.h        **** 
 395:port.h        **** /**
 396:port.h        ****  * \brief Toggle output level on pin
 397:port.h        ****  *
 398:port.h        ****  * Toggle the pin levels on pin
 399:port.h        ****  *
 400:port.h        ****  * \param[in] pin       The pin number for device
 401:port.h        ****  */
 402:port.h        **** static inline void PORTC_toggle_pin_level(const uint8_t pin)
 403:port.h        **** {
 404:port.h        **** 	PINC = 1 << pin;
 405:port.h        **** }
 406:port.h        **** 
 407:port.h        **** /**
 408:port.h        ****  * \brief Get input level on pins
 409:port.h        ****  *
 410:port.h        ****  * Read the input level on pins connected to a port
 411:port.h        ****  *
 412:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 413:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 414:port.h        ****  */
 415:port.h        **** static inline uint8_t PORTC_get_port_level(volatile uint8_t *port)
 416:port.h        **** {
 417:port.h        **** 	return PINC;
 418:port.h        **** }
 419:port.h        **** 
 420:port.h        **** /**
 421:port.h        ****  * \brief Get level on pin
 422:port.h        ****  *
 423:port.h        ****  * Reads the level on a pin connected to a port
 424:port.h        ****  *
 425:port.h        ****  * \param[in] pin       The pin number for device
 426:port.h        ****  */
 427:port.h        **** static inline bool PORTC_get_pin_level(const uint8_t pin)
 428:port.h        **** {
 429:port.h        **** 	return PINC & (1 << pin);
 430:port.h        **** }
 431:port.h        **** 
 432:port.h        **** /**
 433:port.h        ****  * \brief Write value to PORTC
 434:port.h        ****  *
 435:port.h        ****  * Write directly to the entire port register.
 436:port.h        ****  *
 437:port.h        ****  * \param[in] value   Value to write
 438:port.h        ****  */
 439:port.h        **** static inline void PORTC_write_port(const uint8_t value)
 440:port.h        **** {
 441:port.h        **** 	PORTC = value;
 442:port.h        **** }
 443:port.h        **** 
 444:port.h        **** /**
 445:port.h        ****  * \brief Set PORTD pin pull mode
 446:port.h        ****  *
 447:port.h        ****  * Configure pin to pull up, down or disable pull mode, supported pull
 448:port.h        ****  * modes are defined by device used
 449:port.h        ****  *
 450:port.h        ****  * \param[in] pin       The pin number in PORTD
 451:port.h        ****  * \param[in] pull_mode Pin pull mode
 452:port.h        ****  */
 453:port.h        **** static inline void PORTD_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
 454:port.h        **** {
 455:port.h        **** 
 456:port.h        **** 	if (pull_mode == PORT_PULL_UP) {
 457:port.h        **** 
 458:port.h        **** 		DDRD &= ~(1 << pin);
 459:port.h        **** 
 460:port.h        **** 		PORTD |= 1 << pin;
 461:port.h        **** 	} else if (pull_mode == PORT_PULL_OFF) {
 462:port.h        **** 
 463:port.h        **** 		PORTD &= ~(1 << pin);
 464:port.h        **** 	}
 465:port.h        **** }
 466:port.h        **** 
 467:port.h        **** /**
 468:port.h        ****  * \brief Set PORTD data direction
 469:port.h        ****  *
 470:port.h        ****  * Select if the port pins selected by mask data direction is input, output
 471:port.h        ****  * or disabled.
 472:port.h        ****  *
 473:port.h        ****  * \param[in] mask      Bit mask where 1 means apply direction setting to the
 474:port.h        ****  *                      corresponding pin
 475:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 476:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 477:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 478:port.h        ****  *                      (low power state)
 479:port.h        ****  */
 480:port.h        **** static inline void PORTD_set_port_dir(const uint8_t mask, const enum port_dir direction)
 481:port.h        **** {
 482:port.h        **** 	switch (direction) {
 483:port.h        **** 	case PORT_DIR_IN:
 484:port.h        **** 		DDRD &= ~mask;
 485:port.h        **** 		break;
 486:port.h        **** 	case PORT_DIR_OUT:
 487:port.h        **** 		DDRD |= mask;
 488:port.h        **** 		break;
 489:port.h        **** 	case PORT_DIR_OFF:
 490:port.h        **** 		DDRD &= ~mask;
 491:port.h        **** 
 492:port.h        **** 		PORTD |= mask;
 493:port.h        **** 		break;
 494:port.h        **** 	default:
 495:port.h        **** 		break;
 496:port.h        **** 	}
 497:port.h        **** }
 498:port.h        **** 
 499:port.h        **** /**
 500:port.h        ****  * \brief Set PORTD single pin data direction
 501:port.h        ****  *
 502:port.h        ****  * Select if the pin data direction is input, output or disabled.
 503:port.h        ****  * If disabled state is not possible, this function throws an assert.
 504:port.h        ****  *
 505:port.h        ****  * \param[in] pin       The pin number within PORTD (0..7)
 506:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 507:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 508:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 509:port.h        ****  *                      (low power state)
 510:port.h        ****  */
 511:port.h        **** static inline void PORTD_set_pin_dir(const uint8_t pin, const enum port_dir direction)
 512:port.h        **** {
 513:port.h        **** 	switch (direction) {
 514:port.h        **** 	case PORT_DIR_IN:
 515:port.h        **** 		DDRD &= ~(1 << pin);
 516:port.h        **** 		break;
 517:port.h        **** 	case PORT_DIR_OUT:
 518:port.h        **** 		DDRD |= 1 << pin;
 519:port.h        **** 		break;
 520:port.h        **** 	case PORT_DIR_OFF:
 521:port.h        **** 		DDRD |= ~(1 << pin);
 522:port.h        **** 
 523:port.h        **** 		PORTD |= 1 << pin;
 524:port.h        **** 		break;
 525:port.h        **** 	default:
 526:port.h        **** 		break;
 527:port.h        **** 	}
 528:port.h        **** }
 529:port.h        **** 
 530:port.h        **** /**
 531:port.h        ****  * \brief Set PORTD level
 532:port.h        ****  *
 533:port.h        ****  * Sets output level on the pins defined by the bit mask
 534:port.h        ****  *
 535:port.h        ****  * \param[in] mask  Bit mask where 1 means apply port level to the corresponding
 536:port.h        ****  *                  pin
 537:port.h        ****  * \param[in] level true  = Pin levels set to "high" state
 538:port.h        ****  *                  false = Pin levels set to "low" state
 539:port.h        ****  */
 540:port.h        **** static inline void PORTD_set_port_level(const uint8_t mask, const bool level)
 541:port.h        **** {
 542:port.h        **** 	if (level) {
 543:port.h        **** 		PORTD |= mask;
 544:port.h        **** 	} else {
 545:port.h        **** 		PORTD &= ~mask;
 546:port.h        **** 	}
 547:port.h        **** }
 548:port.h        **** 
 549:port.h        **** /**
 550:port.h        ****  * \brief Set PORTD level
 551:port.h        ****  *
 552:port.h        ****  * Sets output level on a pin
 553:port.h        ****  *
 554:port.h        ****  * \param[in] pin       The pin number for device
 555:port.h        ****  * \param[in] level true  = Pin level set to "high" state
 556:port.h        ****  *                  false = Pin level set to "low" state
 557:port.h        ****  */
 558:port.h        **** static inline void PORTD_set_pin_level(const uint8_t pin, const bool level)
 559:port.h        **** {
 560:port.h        **** 	if (level) {
 561:port.h        **** 		PORTD |= 1 << pin;
 562:port.h        **** 	} else {
 563:port.h        **** 		PORTD &= ~(1 << pin);
 564:port.h        **** 	}
 565:port.h        **** }
 566:port.h        **** 
 567:port.h        **** /**
 568:port.h        ****  * \brief Toggle out level on pins
 569:port.h        ****  *
 570:port.h        ****  * Toggle the pin levels on pins defined by bit mask
 571:port.h        ****  *
 572:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 573:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 574:port.h        ****  * \param[in] mask  Bit mask where 1 means toggle pin level to the corresponding
 575:port.h        ****  *                  pin
 576:port.h        ****  */
 577:port.h        **** static inline void PORTD_toggle_port_level(const uint8_t mask)
 578:port.h        **** {
 579:port.h        **** 	PIND = mask;
 580:port.h        **** }
 581:port.h        **** 
 582:port.h        **** /**
 583:port.h        ****  * \brief Toggle output level on pin
 584:port.h        ****  *
 585:port.h        ****  * Toggle the pin levels on pin
 586:port.h        ****  *
 587:port.h        ****  * \param[in] pin       The pin number for device
 588:port.h        ****  */
 589:port.h        **** static inline void PORTD_toggle_pin_level(const uint8_t pin)
 590:port.h        **** {
 591:port.h        **** 	PIND = 1 << pin;
 592:port.h        **** }
 593:port.h        **** 
 594:port.h        **** /**
 595:port.h        ****  * \brief Get input level on pins
 596:port.h        ****  *
 597:port.h        ****  * Read the input level on pins connected to a port
 598:port.h        ****  *
 599:port.h        ****  * \param[in] port  Ports are grouped into groups of maximum 32 pins,
 600:port.h        ****  *                  PORT_PORTA = group 0, PORT_PORTB = group 1, etc
 601:port.h        ****  */
 602:port.h        **** static inline uint8_t PORTD_get_port_level(volatile uint8_t *port)
 603:port.h        **** {
 604:port.h        **** 	return PIND;
 605:port.h        **** }
 606:port.h        **** 
 607:port.h        **** /**
 608:port.h        ****  * \brief Get level on pin
 609:port.h        ****  *
 610:port.h        ****  * Reads the level on a pin connected to a port
 611:port.h        ****  *
 612:port.h        ****  * \param[in] pin       The pin number for device
 613:port.h        ****  */
 614:port.h        **** static inline bool PORTD_get_pin_level(const uint8_t pin)
 615:port.h        **** {
 616:port.h        **** 	return PIND & (1 << pin);
 617:port.h        **** }
 618:port.h        **** 
 619:port.h        **** /**
 620:port.h        ****  * \brief Write value to PORTD
 621:port.h        ****  *
 622:port.h        ****  * Write directly to the entire port register.
 623:port.h        ****  *
 624:port.h        ****  * \param[in] value   Value to write
 625:port.h        ****  */
 626:port.h        **** static inline void PORTD_write_port(const uint8_t value)
 627:port.h        **** {
 628:port.h        **** 	PORTD = value;
 629:port.h        **** }
 630:port.h        **** 
 631:port.h        **** /**
 632:port.h        ****  * \brief Set PORTE pin pull mode
 633:port.h        ****  *
 634:port.h        ****  * Configure pin to pull up, down or disable pull mode, supported pull
 635:port.h        ****  * modes are defined by device used
 636:port.h        ****  *
 637:port.h        ****  * \param[in] pin       The pin number in PORTE
 638:port.h        ****  * \param[in] pull_mode Pin pull mode
 639:port.h        ****  */
 640:port.h        **** static inline void PORTE_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
 641:port.h        **** {
 642:port.h        **** 
 643:port.h        **** 	if (pull_mode == PORT_PULL_UP) {
 644:port.h        **** 
 645:port.h        **** 		DDRE &= ~(1 << pin);
 646:port.h        **** 
 647:port.h        **** 		PORTE |= 1 << pin;
 648:port.h        **** 	} else if (pull_mode == PORT_PULL_OFF) {
 649:port.h        **** 
 650:port.h        **** 		PORTE &= ~(1 << pin);
 651:port.h        **** 	}
 652:port.h        **** }
 653:port.h        **** 
 654:port.h        **** /**
 655:port.h        ****  * \brief Set PORTE data direction
 656:port.h        ****  *
 657:port.h        ****  * Select if the port pins selected by mask data direction is input, output
 658:port.h        ****  * or disabled.
 659:port.h        ****  *
 660:port.h        ****  * \param[in] mask      Bit mask where 1 means apply direction setting to the
 661:port.h        ****  *                      corresponding pin
 662:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 663:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 664:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 665:port.h        ****  *                      (low power state)
 666:port.h        ****  */
 667:port.h        **** static inline void PORTE_set_port_dir(const uint8_t mask, const enum port_dir direction)
 668:port.h        **** {
 669:port.h        **** 	switch (direction) {
 670:port.h        **** 	case PORT_DIR_IN:
 671:port.h        **** 		DDRE &= ~mask;
 672:port.h        **** 		break;
 673:port.h        **** 	case PORT_DIR_OUT:
 674:port.h        **** 		DDRE |= mask;
 675:port.h        **** 		break;
 676:port.h        **** 	case PORT_DIR_OFF:
 677:port.h        **** 		DDRE &= ~mask;
 678:port.h        **** 
 679:port.h        **** 		PORTE |= mask;
 680:port.h        **** 		break;
 681:port.h        **** 	default:
 682:port.h        **** 		break;
 683:port.h        **** 	}
 684:port.h        **** }
 685:port.h        **** 
 686:port.h        **** /**
 687:port.h        ****  * \brief Set PORTE single pin data direction
 688:port.h        ****  *
 689:port.h        ****  * Select if the pin data direction is input, output or disabled.
 690:port.h        ****  * If disabled state is not possible, this function throws an assert.
 691:port.h        ****  *
 692:port.h        ****  * \param[in] pin       The pin number within PORTE (0..7)
 693:port.h        ****  * \param[in] direction PORT_DIR_IN  = Data direction in
 694:port.h        ****  *                      PORT_DIR_OUT = Data direction out
 695:port.h        ****  *                      PORT_DIR_OFF = Disables the pin
 696:port.h        ****  *                      (low power state)
 697:port.h        ****  */
 698:port.h        **** static inline void PORTE_set_pin_dir(const uint8_t pin, const enum port_dir direction)
 699:port.h        **** {
 700:port.h        **** 	switch (direction) {
 701:port.h        **** 	case PORT_DIR_IN:
 702:port.h        **** 		DDRE &= ~(1 << pin);
 213               	.LM7:
 214 0000 6998      	 cbi 0xd,1
 215               	.LBE78:
 216               	.LBE77:
 217               	.LBE76:
 218               	.LBB79:
 219               	.LBB80:
 220               	.LBB81:
 221               	.LBB82:
 650:port.h        **** 	}
 223               	.LM8:
 224 0002 7198      	 cbi 0xe,1
 225               	.LBE82:
 226               	.LBE81:
 227               	.LBE80:
 228               	.LBE79:
 229               	.LBB83:
 230               	.LBB84:
 231               	.LBB85:
 233               	.LM9:
 234 0004 6898      	 cbi 0xd,0
 235               	.LBE85:
 236               	.LBE84:
 237               	.LBE83:
 238               	.LBB86:
 239               	.LBB87:
 240               	.LBB88:
 241               	.LBB89:
 650:port.h        **** 	}
 243               	.LM10:
 244 0006 7098      	 cbi 0xe,0
 245               	 
 246               	.LBE89:
 247               	.LBE88:
 248               	.LBE87:
 249               	.LBE86:
 251               	.Ltext4:
 109:port_init.c   **** 
 110:port_init.c   **** 	PE1_set_dir(
 111:port_init.c   **** 	    // <y> Pin direction
 112:port_init.c   **** 	    // <id> pad_dir
 113:port_init.c   **** 	    // <PORT_DIR_OFF"> Off
 114:port_init.c   **** 	    // <PORT_DIR_IN"> In
 115:port_init.c   **** 	    // <PORT_DIR_OUT"> Out
 116:port_init.c   **** 	    PORT_DIR_IN);
 117:port_init.c   **** 
 118:port_init.c   **** 	PE1_set_pull_mode(
 119:port_init.c   **** 	    // <y> Pull configuration
 120:port_init.c   **** 	    // <id> pad_pull_config
 121:port_init.c   **** 	    // <PORT_PULL_OFF"> Off
 122:port_init.c   **** 	    // <PORT_PULL_UP"> Pull-up
 123:port_init.c   **** 	    PORT_PULL_OFF);
 124:port_init.c   **** 
 125:port_init.c   **** 	PE0_set_dir(
 126:port_init.c   **** 	    // <y> Pin direction
 127:port_init.c   **** 	    // <id> pad_dir
 128:port_init.c   **** 	    // <PORT_DIR_OFF"> Off
 129:port_init.c   **** 	    // <PORT_DIR_IN"> In
 130:port_init.c   **** 	    // <PORT_DIR_OUT"> Out
 131:port_init.c   **** 	    PORT_DIR_IN);
 132:port_init.c   **** 
 133:port_init.c   **** 	PE0_set_pull_mode(
 134:port_init.c   **** 	    // <y> Pull configuration
 135:port_init.c   **** 	    // <id> pad_pull_config
 136:port_init.c   **** 	    // <PORT_PULL_OFF"> Off
 137:port_init.c   **** 	    // <PORT_PULL_UP"> Pull-up
 138:port_init.c   **** 	    PORT_PULL_OFF);
 139:port_init.c   **** 
 140:port_init.c   **** }
 253               	.LM11:
 254 0008 0895      	 ret
 256               	.Lscope2:
 258               	 .stabd 78,0,0
 259               	 .section .text.port_init,"ax",@progbits
 261               	.global port_init
 263               	port_init:
 264               	 .stabd 46,0,0
 141:port_init.c   **** 
 142:port_init.c   **** void port_init()
 143:port_init.c   **** {
 266               	.LM12:
 267               	.LFBB3:
 268               	 
 269               	 
 270               	 
 271               	.L__stack_usage =0
 144:port_init.c   **** 	I2C_0_initialization();
 273               	.LM13:
 274 0000 0E94 0000 	 call I2C_0_initialization
 275               	.LBB136:
 276               	.LBB137:
 277               	.LBB138:
 279               	.Ltext5:
 141:port.h        **** 		break;
 281               	.LM14:
 282 0004 2698      	 cbi 0x4,6
 283               	.LBE138:
 284               	.LBE137:
 285               	.LBE136:
 286               	.LBB139:
 287               	.LBB140:
 288               	.LBB141:
  89:port.h        **** 	}
 290               	.LM15:
 291 0006 2E98      	 cbi 0x5,6
 292               	.LBE141:
 293               	.LBE140:
 294               	.LBE139:
 295               	.LBB142:
 296               	.LBB143:
 297               	.LBB144:
 328:port.h        **** 		break;
 299               	.LM16:
 300 0008 3998      	 cbi 0x7,1
 301               	.LBE144:
 302               	.LBE143:
 303               	.LBE142:
 304               	.LBB145:
 305               	.LBB146:
 306               	.LBB147:
 307               	.LBB148:
 276:port.h        **** 	}
 309               	.LM17:
 310 000a 4198      	 cbi 0x8,1
 311               	.LBE148:
 312               	.LBE147:
 313               	.LBE146:
 314               	.LBE145:
 315               	.LBB149:
 316               	.LBB150:
 317               	.LBB151:
 515:port.h        **** 		break;
 319               	.LM18:
 320 000c 5398      	 cbi 0xa,3
 321               	.LBE151:
 322               	.LBE150:
 323               	.LBE149:
 324               	.LBB152:
 325               	.LBB153:
 326               	.LBB154:
 327               	.LBB155:
 463:port.h        **** 	}
 329               	.LM19:
 330 000e 5B98      	 cbi 0xb,3
 331               	.LBE155:
 332               	.LBE154:
 333               	.LBE153:
 334               	.LBE152:
 335               	.LBB156:
 336               	.LBB157:
 337               	.LBB158:
 515:port.h        **** 		break;
 339               	.LM20:
 340 0010 5598      	 cbi 0xa,5
 341               	.LBE158:
 342               	.LBE157:
 343               	.LBE156:
 344               	.LBB159:
 345               	.LBB160:
 346               	.LBB161:
 347               	.LBB162:
 463:port.h        **** 	}
 349               	.LM21:
 350 0012 5D98      	 cbi 0xb,5
 351               	.LBE162:
 352               	.LBE161:
 353               	.LBE160:
 354               	.LBE159:
 355               	.LBB163:
 356               	.LBB164:
 357               	.LBB165:
 703:port.h        **** 		break;
 704:port.h        **** 	case PORT_DIR_OUT:
 705:port.h        **** 		DDRE |= 1 << pin;
 359               	.LM22:
 360 0014 6B9A      	 sbi 0xd,3
 361               	.LBE165:
 362               	.LBE164:
 363               	.LBE163:
 364               	.LBB166:
 365               	.LBB167:
 366               	.LBB168:
 706:port.h        **** 		break;
 707:port.h        **** 	case PORT_DIR_OFF:
 708:port.h        **** 		DDRE |= ~(1 << pin);
 709:port.h        **** 
 710:port.h        **** 		PORTE |= 1 << pin;
 711:port.h        **** 		break;
 712:port.h        **** 	default:
 713:port.h        **** 		break;
 714:port.h        **** 	}
 715:port.h        **** }
 716:port.h        **** 
 717:port.h        **** /**
 718:port.h        ****  * \brief Set PORTE level
 719:port.h        ****  *
 720:port.h        ****  * Sets output level on the pins defined by the bit mask
 721:port.h        ****  *
 722:port.h        ****  * \param[in] mask  Bit mask where 1 means apply port level to the corresponding
 723:port.h        ****  *                  pin
 724:port.h        ****  * \param[in] level true  = Pin levels set to "high" state
 725:port.h        ****  *                  false = Pin levels set to "low" state
 726:port.h        ****  */
 727:port.h        **** static inline void PORTE_set_port_level(const uint8_t mask, const bool level)
 728:port.h        **** {
 729:port.h        **** 	if (level) {
 730:port.h        **** 		PORTE |= mask;
 731:port.h        **** 	} else {
 732:port.h        **** 		PORTE &= ~mask;
 733:port.h        **** 	}
 734:port.h        **** }
 735:port.h        **** 
 736:port.h        **** /**
 737:port.h        ****  * \brief Set PORTE level
 738:port.h        ****  *
 739:port.h        ****  * Sets output level on a pin
 740:port.h        ****  *
 741:port.h        ****  * \param[in] pin       The pin number for device
 742:port.h        ****  * \param[in] level true  = Pin level set to "high" state
 743:port.h        ****  *                  false = Pin level set to "low" state
 744:port.h        ****  */
 745:port.h        **** static inline void PORTE_set_pin_level(const uint8_t pin, const bool level)
 746:port.h        **** {
 747:port.h        **** 	if (level) {
 748:port.h        **** 		PORTE |= 1 << pin;
 368               	.LM23:
 369 0016 739A      	 sbi 0xe,3
 370               	 
 371               	.LBE168:
 372               	.LBE167:
 373               	.LBE166:
 375               	.Ltext6:
 145:port_init.c   **** 
 146:port_init.c   **** 	//I2C_1_initialization();
 147:port_init.c   **** 
 148:port_init.c   **** 	/* PORT setting on PB6 */
 149:port_init.c   **** 
 150:port_init.c   **** 	// Set pin direction to input
 151:port_init.c   **** 	ADDR_IN_set_dir(PORT_DIR_IN);
 152:port_init.c   **** 
 153:port_init.c   **** 	ADDR_IN_set_pull_mode(
 154:port_init.c   **** 	    // <y> Pull configuration
 155:port_init.c   **** 	    // <id> pad_pull_config
 156:port_init.c   **** 	    // <PORT_PULL_OFF"> Off
 157:port_init.c   **** 	    // <PORT_PULL_UP"> Pull-up
 158:port_init.c   **** 	    PORT_PULL_OFF);
 159:port_init.c   **** 
 160:port_init.c   **** 	/* PORT setting on PB7 */
 161:port_init.c   **** 
 162:port_init.c   **** 	// Set pin direction to input
 163:port_init.c   **** 	/*MST_set_dir(PORT_DIR_IN);
 164:port_init.c   **** 
 165:port_init.c   **** 	MST_set_pull_mode(
 166:port_init.c   **** 	    // <y> Pull configuration
 167:port_init.c   **** 	    // <id> pad_pull_config
 168:port_init.c   **** 	    // <PORT_PULL_OFF"> Off
 169:port_init.c   **** 	    // <PORT_PULL_UP"> Pull-up
 170:port_init.c   **** 	    PORT_PULL_UP);
 171:port_init.c   **** 		*/
 172:port_init.c   **** 	/* PORT setting on PC0 */
 173:port_init.c   **** 
 174:port_init.c   **** 	// Set pin direction to output
 175:port_init.c   **** 	/*SYNC_set_dir(PORT_DIR_IN);
 176:port_init.c   **** 
 177:port_init.c   **** 	SYNC_set_pull_mode(
 178:port_init.c   **** 	    // <y> Pull configuration
 179:port_init.c   **** 	    // <id> pad_pull_config
 180:port_init.c   **** 	    // <PORT_PULL_OFF"> Off
 181:port_init.c   **** 	    // <PORT_PULL_UP"> Pull-up
 182:port_init.c   **** 	    PORT_PULL_OFF);*/
 183:port_init.c   **** 
 184:port_init.c   **** 
 185:port_init.c   **** 	/* PORT setting on PC1 */
 186:port_init.c   **** 
 187:port_init.c   **** 	// Set pin direction to input
 188:port_init.c   **** 	ADDR_OUT_set_dir(PORT_DIR_IN);
 189:port_init.c   **** 
 190:port_init.c   **** 	ADDR_OUT_set_pull_mode(
 191:port_init.c   **** 	// <y> Pull configuration
 192:port_init.c   **** 	// <id> pad_pull_config
 193:port_init.c   **** 	// <PORT_PULL_OFF"> Off
 194:port_init.c   **** 	// <PORT_PULL_UP"> Pull-up
 195:port_init.c   **** 	PORT_PULL_OFF);
 196:port_init.c   **** 
 197:port_init.c   **** 
 198:port_init.c   **** 	/* PORT setting on PC2 */
 199:port_init.c   **** 
 200:port_init.c   **** 	// Set pin direction to output
 201:port_init.c   **** 	/*XSHUT_set_dir(PORT_DIR_OUT);
 202:port_init.c   **** 
 203:port_init.c   **** 	XSHUT_set_level(
 204:port_init.c   **** 	    // <y> Initial level
 205:port_init.c   **** 	    // <id> pad_initial_level
 206:port_init.c   **** 	    // <false"> Low
 207:port_init.c   **** 	    // <true"> High
 208:port_init.c   **** 	    true);*/
 209:port_init.c   **** 
 210:port_init.c   **** 	/* PORT setting on PC3 */
 211:port_init.c   **** 
 212:port_init.c   **** 	// Set pin direction to input
 213:port_init.c   **** 	/*GPIO1_set_dir(PORT_DIR_IN);
 214:port_init.c   **** 
 215:port_init.c   **** 	GPIO1_set_pull_mode(
 216:port_init.c   **** 	    // <y> Pull configuration
 217:port_init.c   **** 	    // <id> pad_pull_config
 218:port_init.c   **** 	    // <PORT_PULL_OFF"> Off
 219:port_init.c   **** 	    // <PORT_PULL_UP"> Pull-up
 220:port_init.c   **** 	    PORT_PULL_OFF);*/
 221:port_init.c   **** 
 222:port_init.c   **** 	/* PORT setting on PD3 */
 223:port_init.c   **** 
 224:port_init.c   **** 	// Set pin direction to input
 225:port_init.c   **** 	GND_set_dir(PORT_DIR_IN);
 226:port_init.c   **** 
 227:port_init.c   **** 	GND_set_pull_mode(
 228:port_init.c   **** 	    // <y> Pull configuration
 229:port_init.c   **** 	    // <id> pad_pull_config
 230:port_init.c   **** 	    // <PORT_PULL_OFF"> Off
 231:port_init.c   **** 	    // <PORT_PULL_UP"> Pull-up
 232:port_init.c   **** 	    PORT_PULL_OFF);
 233:port_init.c   **** 
 234:port_init.c   **** 	/* PORT setting on PD5 */
 235:port_init.c   **** 
 236:port_init.c   **** 	// Set pin direction to input
 237:port_init.c   **** 	GND2_set_dir(PORT_DIR_IN);
 238:port_init.c   **** 
 239:port_init.c   **** 	GND2_set_pull_mode(
 240:port_init.c   **** 	    // <y> Pull configuration
 241:port_init.c   **** 	    // <id> pad_pull_config
 242:port_init.c   **** 	    // <PORT_PULL_OFF"> Off
 243:port_init.c   **** 	    // <PORT_PULL_UP"> Pull-up
 244:port_init.c   **** 	    PORT_PULL_OFF);
 245:port_init.c   **** 
 246:port_init.c   **** 	/* PORT setting on PE3 */
 247:port_init.c   **** 
 248:port_init.c   **** 	// Set pin direction to output
 249:port_init.c   **** 	LED_set_dir(PORT_DIR_OUT);
 250:port_init.c   **** 
 251:port_init.c   **** 	LED_set_level(
 252:port_init.c   **** 	    // <y> Initial level
 253:port_init.c   **** 	    // <id> pad_initial_level
 254:port_init.c   **** 	    // <false"> Low
 255:port_init.c   **** 	    // <true"> High
 256:port_init.c   **** 	    true);
 257:port_init.c   **** 
 258:port_init.c   **** 
 259:port_init.c   **** 
 260:port_init.c   **** }
 377               	.LM24:
 378 0018 0895      	 ret
 380               	.Lscope3:
 382               	 .stabd 78,0,0
 383               	 .text
 385               	.Letext0:
 386               	 .ident "GCC: (GNU) 9.1.0"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 port_init.c
    {standard input}:2      *ABS*:000000000000003e __SP_H__
    {standard input}:3      *ABS*:000000000000003d __SP_L__
    {standard input}:4      *ABS*:000000000000003f __SREG__
    {standard input}:5      *ABS*:0000000000000000 __tmp_reg__
    {standard input}:6      *ABS*:0000000000000001 __zero_reg__
    {standard input}:115    .text.I2C_0_initialization:0000000000000000 I2C_0_initialization
    {standard input}:198    .text.I2C_1_initialization:0000000000000000 I2C_1_initialization
    {standard input}:263    .text.port_init:0000000000000000 port_init

NO UNDEFINED SYMBOLS
